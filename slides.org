* Introduction

What I mean by "Type Aided Programming"?

- *Rule 1*, keep the definition of the types as close as possible to the set of
  values that you know are good.

  #+BEGIN_SRC typescript
  // Bad ðŸš¨
  type Action = { name: string;
                  key: string;
                  value?: string;
                }
  #+END_SRC

  #+BEGIN_SRC typescript
  // Good âœ…
  type Action =
    | { name: "GET";
        key: string
      }
    | { name: "PUT";
        key: string;
        value: string
      }
    | { name: "DEL";
        key: string
      };
  #+END_SRC

- *Rule 2*, be as strict as possibile with the outside world because it's dark and
  full of terrors.

  What I mean is that you should:
  - Validate incoming requests.
  - Validate incoming messages (Ex. queues).
  - Validate external configuration.
  - Validate database data (... let's talk about it).

- *Rule 3*, do not cheat (altough sometimes TypeScript may need a little help).

  Scenario: you have JSON schema for an incoming request and a library able to
  validate at runtime the request given the schema, since this is done at
  run-time you have no type-level knowledge of the types. What you can do is to
  derive the type of the payload of the request from the schema and cast it
  after the validation.

  #+BEGIN_SRC typescript
  type Payload = FromSchema<typeof payloadSchema>;

  const validationResult = validate(payload);

  if (validationResult.isOk) {
    // If the run-time validation is ok then we can safely assume
    // that the type of payload is the type derived from the schema.
    // Spoiler: see the last challenge of the workshop.
    const payload = validationResult.data as unknown as Payload;
  }
  #+END_SRC

* More Formally

It's achieved by representing truths or constraints in the language type system
so that when they become false the compilation fails.

#+BEGIN_SRC typescript :tangle snippets/companies.ts
const companies = ["Google", "Facebook", "Apple"] as const;

type Companies = (typeof companies)[number];

type CompanyConfiguration = { rating: number };

type Configuration = {
  [K in Companies]: CompanyConfiguration;
};

const configuration: Configuration = {
  Google: { rating: 3 },
  Facebook: { rating: 1 },
  Apple: { rating: 2 },
};

export { configuration };
#+END_SRC

- [[file:snippets/companies.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBKC2AHAhmAlgUwjAvDA2gEQDiIIA5gDYaEA0MhAYssBgEZkDWdDAgoomqEAujGTZQkKAG4AULKgBPRBhgBhEElSZseABRKVIAGZxNKdFgCU+MAFd4bDACdhchctUatYRRrDGaOR2zshQaOC4MADeMKHhYOQAXDD2ji4wAL7uhl7ggcHxEWBR0bIwBADSMGgl3hY6win1qH75QSFhxXLZ8pLQZgEdReDN7YVdkXhlFaQU1CmxRYkpAMxZtOUwzKwcIJyLcV0rMACMG1v8ghiHy8kwAEwXvbIYAB6IIM6wsZIFneFIr0gA][Playground]])

* Why TypeScript?

Why TypeScript? TypeScript type system is (incidentally) more advanced than what
you (probably) think. TypeScript's type system is a full-fledged turing complete
programming language, limited, but powerful.

We will refer to the subset of TypeScript that deals with types and guides the
type checker as the "Type-Level TypeScript" programming language.

Every programming language is about transforming data, /Type-Level TypeScript/
is not exception, but its purpose is to *transform types*.

NOTE: This approach is orthogonal to /Object-Oriented Programming/ and
/Functional Programming/ it can be applied with both.

* Types

You can view types as sets, aka a type is isomorphic to the set of values of
that type.

#+BEGIN_SRC typescript
type Primitives =
  | number
  | string
  | boolean
  | symbol
  | bigint
  | undefined
  | null;

type Literals =
  | 20
  | "Hello"
  | true
  | 10000n

type DataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
#+END_SRC

* Composing Types

There are two ways of composing types. They are not operators, they are
constructors, they act on types but they don't manipulate them, they put them in
a box, we can still access those types and manipulate them later.

** Union Types

You can read as: a value of type ~TurnAction~ can have either a value of type
~"left"~ or a value of type ~"right"~

If you look at types as sests, the type constructor ~|~ is the equivalent of
union for sets.

#+BEGIN_SRC typescript
type TurnAction = "left" | "right";
#+END_SRC

** Intersection Types

You can read as: a value of type ~Employee~ has a field ~"id"~ of type ~string~,
a field ~reportTo~ of either type ~Employee~ or ~null~ and it must be also a
value of type ~Person~.

If you look at types as sests, the type constructor ~&~ is the equivalent of
intersection for sets.

#+BEGIN_SRC typescript
type Person = {firstName: string, lastName: string};

type Employee = {id: string, reportTo: Employee | null} & Person;
#+END_SRC

** Exercises

- What's the type of ~string & "foo"~?
- What's the type of ~true | false~?

* Special Types: Never

Type ~never~ is the subtype of every type, it's also called /bottom/ (symbol: âŠ¥)
because if you visualize the type hierarchies with supertypes at the top are at
the it occupies the bottom.

If you look at types as sests, the type ~never~ is the empty set.

A ~never~ value can be assigned to every type, but you cannot produce a value of
type ~never~, and for that it will be very useful.

#+BEGIN_SRC typescript
type X = never | string; // string
type Y = never & string; // never
#+END_SRC

It can always be placed on the right side of an assignment and never on the
left (TODO: see assignability).

#+BEGIN_SRC typescript :tangle snippets/never.ts
// @ts-expect-error only never can be assigned to never
const x: never = null;

// never can be assigned to eveyrhing
// ...but you have to cheat to create a value of type never
const y: string = undefined as never;

export { x, y };
#+END_SRC

- [[file:snippets/never.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAEBcGcFoFMAeAHeBjSCBOWD2XRcA7AGwE9Qj4A3eAtAQyNACN5QHpoBLAcyoAmoSLko06AKDTFokUIgBcY2gQC8lAK4kSAbgkSQyuqEbM2HLn0HDR4slgAW3IrwNgAdJ5Ya5ZXBtAHBlobEwd4BjkREywIyHYGUGoGEg12XAAzYTJUIywpGV8lWSxnXlB1DSIBeAzneCFOPL0JJGR8OQBveQAaUAoAXwkgA][Playground]])

** Ensure Code is Unreacheable

#+BEGIN_SRC typescript :tangle snippets/unreacheable.ts
const companies = ["Google", "Facebook", "Apple"] as const;

type Companies = (typeof companies)[number];

function unreacheable(_: never): void {
  throw new Error("unreacheable");
}

declare const x: Companies;

switch (x) {
  case "Google":
    // do something
    break;
  case "Apple":
    // do something
    break;
  case "Facebook":
    // do something
    break;
  default:
    unreacheable(x);
}

switch (x) {
  case "Google":
    // do something
    break;
  case "Apple":
    // do something
    break;
  default:
    // @ts-expect-error Argument of type `"Facebook"` is not assignable to type `never`
    unreacheable(x);
}
#+END_SRC

- [[file:snippets/unreacheable.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBKC2AHAhmAlgUwjAvDA2gEQDiIIA5gDYaEA0MhAYssBgEZkDWdDAgoomqEAujGTZQkKAG4AULKgBPRBhgBhEElSZseABRKVIAGZxNKdFgCU+MAFd4bDACdhc2cbthgUNOBhezhgsABbBbNR6APoAXDBgGABuLlZxiSBoACYwAN6yMDBQIc4gAO7xGOUAos4lznqEgcHAYcgRNFZyAL7ymRjAlMhBZlIwAB5xGlqWEO4QpWhQLTB6Y1a5+XDiqiRkVDQxmwUA9McwmSAwEJoYRWhg5EcwbEHInHIFwNt8AkKHBSczhcrjc7g8ni9gu9Nl8IDtmKwOCBuP8AadzpdrvBbiF7o8Ac9XtCCn1jMg7JQoKiCk1QuFImtuvJ5otlqt1nlPt9dhQ-k90cCsTi8RCiR8tnCfoIDvygZjQbjwQTIW9xaTyZTqTB0QABKAQAC0GDGKh8RtqIGcMF4znIDgwYFgJkKylUAAMmCx2FxCG6YGhsGAQLBxBA0OQwG1qIVLoZ3Qlks43U9aS16Rh2UygA][Playground]])

* Special Types: Unknown

Type ~unknown~ is the supertype of every type, it's also called /top/ (symbol:
âŠ¤) because if you visualize the type hierarchies with supertypes are at the top
the it occupies the top.

If you look at types as sests, the type ~unknown~ is the superset of every set.

#+BEGIN_SRC typescript
type X = unknown & number; // number
type Y = unknown | number; // unknown
#+END_SRC

A value of every type can be assigned to ~unknown~, an ~unknown~ value cannot be
assigned to anything.

#+BEGIN_SRC typescript :tangle snippets/unknown.ts
declare const x: unknown;

// @ts-expect-error `unknown` cannot be assigned to type `string` (downcast)
const y: string = x;

const z: unknown = "anything";
#+END_SRC

- [[file:snippets/unknown.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEYD2A7AzgF3gDwFzwFcUBrFJAdxQG4AoGgenvgAEM0BaEbAB3A05gwkMeAAMipCilGIoKMlgBGCKGjQBLAOYoQweBiT6AnrzGYY6lJpkAKYFLCqMAShrJ0WI-nOXN8ALw4tG6omPAAXvgSZJQB8ABEckYYABa+8bRAA][Playground]])

So everything can become ~unknown~ (upcasting) but you cannot do anything with a
value of type ~unknown~.

* Special Types

- Type ~any~ is another top (âŠ¤) like ~unknown~, but you can do everything with
  it. To be more precise is the sum type of every type but not quite. Very
  dangerous, do not use it, use ~unknown~ (always have ~strict: true~ in your
  ~tsconfig.json~ configuration)

- Type ~undefined~ has a value ~undefined~, ~undefined~ is a subtype of every
  type, meaning ~undefined~ is another kind of bottom, but this time (as opposed
  to ~never~) it has a value which is ~undefined~. You can avoid this with
  ~strictNullChecks: true~ in ~tsconfig.json~ (included in ~strict: true~), with
  this flag the only value of type ~undefined~ is ~undefined~ itself.

- A declared variable has value ~undefined~ before its first assignment.

- Type ~void~ represents the absence of value, ~undefined~ is a value of type
  void.

- Type ~null~ has a value ~null~, ~null~ is a subtype of every
  type, meaning ~null~ is another kind of bottom, but this time (as opposed
  to ~never~) it has a value which is ~null~. You can avoid this with
  ~strictNullChecks: true~ in ~tsconfig.json~ (included in ~strict: true~), with
  this flag the only value of type ~null~ is ~null~ itself.

- A ~null~ value is an object (due to an error in the original JavaScript
  implementation ðŸ¤®)

- TLDR:
  - Always have ~strict: true~ in your ~tsconfig.json~ file.
  - Always use ~unknown~ instead of ~any~.
  - Always use ~undefined~ instead of ~null~.

* Generics

A generic type, is a "parametric polymorphic" type.

#+BEGIN_QUOTE
In programming languages and type theory, parametric polymorphism allows a
single piece of code to be given a "generic" type, using variables in place of
actual types, and then instantiated with particular types as needed.
#+END_QUOTE

We call variables that stands for a type "Type Variables".

We call a type without type variables a "Complete Type" o "Concrete Type".

We can introduce type variables in different places:

- Interfaces
  #+BEGIN_SRC typescript
  interface Container<T> {
      content: T;
  }
  #+END_SRC

- Classes
  #+BEGIN_SRC typescript
  class Container<T> {
      constructor (private readonly content: T) {};
  }
  #+END_SRC

- Functions
  #+BEGIN_SRC typescript
  const container = <T,>(content: T) => ({content});
  #+END_SRC

- Type definitions
  #+BEGIN_SRC typescript
  type Container<T> = {content: T}
  #+END_SRC

** Type Constraints

On a /Type Parameter/ we can specify constraints (/Constrained Parametric
Polymorphism/)

Useful feature because by enforcing constraints on a /Type Parameter/ we can
tell TypeScript what you can do with a value of that type. Moreover since
TypeScript is structurally typed the constaints are quite flexible.

#+BEGIN_SRC typescript
class Greetings<Named extends {name: string}> {
  constructor(private readonly subject: Named) {}

  render(): string {
    return `Hello ${this.subject.name}`;
  }
}
#+END_SRC

** Use of Never as Type Parameter

#+BEGIN_SRC typescript
type Result<T, E> = {_tag: "ok", value: T} | {_tag: "error", value: E}

type Flawless<T> = Result<T, never>;
#+END_SRC

** Exercise pickOne

#+BEGIN_SRC typescript :tangle snippets/pickOne.ts
// eslint-disable-next-line
// @ts-nocheck

function pickOne(a: TODO, b: TODO): TODO {
  return Math.random() > 0.5 ? a : b;
}

const r01 = pickOne(true, false);
type T01 = Expect<Equal<typeof r01, boolean>>;

const r02 = pickOne(1, 2);
type T02 = Expect<Equal<typeof r02, 1 | 2>>;

const r03 = pickOne(2, "some string");
type T03 = Expect<Equal<typeof r03, 2 | "some string">>;

const r04 = pickOne(true, 7);
type T04 = Expect<Equal<typeof r04, true | 7>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/pickOne.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8gMwFd4TRLAbxQAB1icA8oQAUmAFygAKtIAi0gDShsytZoCU+jdNABvcqFAAncIj42xAWUyIWAOhuZ4qBgFs5Q1AAPlAABg8AVlAAflBMUGVsAG5yAF9uJlFIRFtwgEZQAF4JKQ5ZcDlEGz5wHR5MaEhwQzTEAE9xcFVCktAAUSJuoQAeAYBHPibRzu6GHnyCnWwGBjwfEJC08mz4XPyAJn7JGXll0EO28jmelXDj0qGRxHGpmduFo50igB9LrY7PYHGzhADMJ3KlTkhx0ACJIAEerkbAgAOZw663XoQp7DdivSbTaCzLrgL6gsE6Y7-BFI0Ao9FwwFZHJ5UEAFkhZyqNTqOgA7Fiyb0uXiXm9iaT5otOTo+T1-gKWTcRQYzKVCAA3cA2doi54E0YqCAkcC+SCgBVhUoqfXdQbvEkADR0AE0bVZQHJjSEgiUwibiIhzahLc64qAisorqaQxbQL7-cVA3HQ5a3ZHo5cvdZ4grc0lQI1muAdsRxAwbHlzL0LvdYTidPcOc3TKB0mkgA][Playground]])
- [[file:solutions/pickOne.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/GYVwdgxgLglg9mABABxhA1geTAUwDwAaANIgJoB8AFAIYBcixiARvaQJT0GIA+ZiA3gChEiAE44oIUUgCy1KAAsAdKOpgAJnAC2lNonKIADEoCsiAPyJqiekwDcggL6DBEBAGcoYwwEZEAXhQ0LFxKKFEQHBJgagAbdxw2BygAT2QcRAAVXwDEAFEAD3ToPDyARxA4vFT0uGBvHxImODhYnDVycgdXDy9RQwAmXNQMbBxKRsQBpMEajOyhwMLiqFKKqrm67wGSP14Bzu63ME9vAGZh4LHKHcQAIndtDM9RGDAAczuZuazDC6WijgSuVKrFqmkcFt+mcSENeA8nogXm9PocXMdTv0ACyXUahcKREgAdm+EN+OIBKzWoPBtXq2JIBIyvCJaNmZMymAAIphcrgAG44UTJMnLIGrTKIHAFKA4DTuRBMgyBTIi9L5dZgxgUALCRCUPCZKh6fwGSXS2XyhgWRB+ejTKUyuXqBWG40BM2Oy0uviWO1TPUiSxMwM2RAxeI4brS5BwURefi-SYLEjZGHk1Pc3mOBxAA][Playground]])

** Exercise mergeTwo

#+BEGIN_SRC typescript :tangle snippets/mergeTwo.ts
// eslint-disable-next-line
// @ts-nocheck

function mergeTwo(a: TODO, b: TODO): TODO {
  return { ...a, ...b };
}

const r01 = mergeTwo({ name: "Bob" }, { age: 42 });
type T01 = Expect<Equal<typeof r01, { name: string } & { age: number }>>;

const r02 = mergeTwo({ greeting: "Hello" }, {});
type T02 = Expect<Equal<typeof r02, { greeting: string }>>;

const r03 = mergeTwo({}, { greeting: "Hello" });
type T03 = Expect<Equal<typeof r03, { greeting: string }>>;

const r04 = mergeTwo({ a: 1, b: 2 }, { c: 3, d: 4 });
type T04 = Expect<
  Equal<typeof r04, { a: number; b: number } & { c: number; d: number }>
>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/mergeTwo.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8gMwFd4TRLAbxQAW3AAnAObgAKgHcGACkwAuUPIDyAEW0AaUNk079ASlN7toAN7lQoKeER8pY26AB0PzEZ9e2KAAvgDc5MHcTKKQiE4ADACMoAC8EtJySqqe8JiSmgBEAEIM2AUhRp6YcpoALABMIebhiACeAA7gWkmpoACiRJ1CADx9AI58mNDDbZ0MPAmJlaC5+aCxUggyIaAAZHag1eCa8Hzi2NIhAHxX4eTR8LEJjWmSsgrKKp4yzi5bhQAJcDQaAMcrBSrBZrkWZdeTxF79QbsRCjCZTGYdcDzZ7LH7gP7wGSaDZba63KIxOJSeIAZl6b0yn1sEIO+MJxNABSBILBTRaWO69LSAyGqPGk2msJxNNpeN+wiJJMQmyJ5LuDyeNNqDIyH2yh00S2MmkarM8TE0ctAqDq-JhgvhOpFyJGDn66KlWJl8Vqyw0KzOFykoRNgfOl2CewOlvDwdDtrjkau5ApDs6WmsvUIADdpAKM6KUcN5BASOB4KhIKAVXxwFdevIC10JRiABpGACaDZS7pUJauKnMqQbpeIiArVdAbdAAH5QMlTcPx5PqwOhyOtGWJ5Xq525wvQKb3Y557XwCej6AeFNIOA7sR2gwpHFPPDjfD6kZ4dand+s2E5BAA][Playground]])
- [[file:solutions/mergeTwo.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/GYVwdgxgLglg9mABAWwKYCcDmqAqB3OAHgA0AaRATQD4AKAQwC5EzEAjJigSieMQDJKiAN4AoRInSooIdEiGIAdErrklC1ogC+AbhGaRIiAgDOUCamMBGRAF4UGbPjg15YOmiYAiAEJxWnrXJ5OmwmABYAJi1OXSgATwAHVEQoCyhrOwBRAA8k6EJMgEcQOgAbQnikuGBzKyDENw9EU3QYMEwtfmFEENQmMBBkVgwtKipdQxMzSWMouzQsXAIXRExJKTbMLwAJVFLSuADNIM0YkUrk1NM5xBy8qALisorE1GraiPq11A32phbNqNxgYjGBTLUAMy2eyLJwuY7db6-LaITy7faHaKxV4pNJQrK5VD5IolcoXd4zCFfdawP7NKCtdpAiag8EzMLQhaOZbBJiWcjsRBRBHyCBMKmIAAm4Sx5xxVygHIJ90IYluTzJrwpFjC9UYDUGw3Q2jY-UNI00XVFZqGGBN0oNtvQoxEwLlSUQOAA8gARL3QsCoABudvdyTuRIeOEQqGyqTAkuMKXQIFQVGhOGxHpJzxY1FsapohBwtE4tnT0dj8cTzEQAH5ENYmBEy1XUAmk8XS+XPTG4+2axR643EM21eIGwzU+PR4hgGVjKgJrGEnB0GZ5Ar+bjruQFRKFbrPb7-ToREA][Playground]])

* Structural Typing, Subtyping & Assignability

A programming language is /Structurally Typed/ when type compatibility and
equivalence are determined by the type's actual structure or definition and not
by other characteristics such as its name or place of declaration.

When ~X~ can be used in place of ~Y~ then ~X~ is a subtype of ~Y~ therefore ~X~
is assignable to Y (see "substitution principle").

When ~X~ is a subtype of ~Y~ therefore ~X~ is assignable to ~Y~.

#+BEGIN_SRC typescript
declare const x: SUBTYPE;

const y: SUPERTYPE = x;
#+END_SRC

You can also say that /Upcasting/ is always safe, /Downcasting/ must be proved.

In a structurally typed programming language types can be structurally inferred
and not declared.

#+BEGIN_SRC typescript :tangle snippets/turns.ts
type Turns = "left" | "right";
type Directions = "up" | "down" | "left" | "right";

// Directions is a subtype of Turns
const t: Turns = "left";
const d: Directions = t;
#+END_SRC

Structural typing is more flexible than nominal typing.

Dig deeper [[https://github.com/microsoft/TypeScript-New-Handbook/blob/master/reference/Assignability.md][here]] and [[https://www.typescriptlang.org/docs/handbook/type-compatibility.html][here]].

** Branded Types

Structural typing sometimes is not what you want.

#+BEGIN_SRC typescript :tangle snippets/structuralClasses.ts
class Foo {
  constructor(public readonly id: string) {}
}

class Bar {
  constructor(public readonly id: string) {}
}

// Probably not what you want
const x: Bar = new Foo("123");

export { x };
#+END_SRC

- [[file:snippets/structuralClasses.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYGwhgzhAEBiD29oG8BQ1rHgOwgFwCcBXYPeAgCgAciAjEAS2GgIFMwATHEAT2gY4AuaPgINsAcwCUKAL6p5qUJBgAhMARTpMOUSTKUa9Ji3ZdsvfkJGFx0uQtSoA9M+gAFAvFph6fbPB40ADuABZgQTzwRCFg2HhKukEAHsLqmgC80NiswXCIFABEAIwATADMhVIA3E6syVTkQcjQydCytUA][Playground]])

Brands to the rescue

#+BEGIN_SRC typescript :tangle snippets/brandedClasses.ts
class Foo {
  private readonly __brand = "Foo";
  constructor(public readonly id: string) {}
}

class Bar {
  private readonly __brand = "Bar";
  constructor(public readonly id: string) {}
}

// @ts-expect-error type Foo is not assignable to type Bar
const x: Bar = new Foo("123");

export { x };
#+END_SRC

We can also brand primitives to improve type safety

#+BEGIN_SRC typescript :tangle snippets/brandedPrimitives.ts
const __brand = Symbol("__brand");

type Brand<B> = { readonly [__brand]: B };

type Branded<T, B> = T & Brand<B>;

const makeBrand =
  <const B>(_b: B) =>
  <T>(t: T): Branded<T, B> =>
    t as unknown as Branded<T, B>;

type UserID = Branded<string, "UserID">;
const makeUserID = makeBrand("UserID");
type User = { id: UserID };

const user: User = { id: makeUserID("123") };

type CompanyID = Branded<string, "CompanyID">;
const makeCompanyID = makeBrand("CompanyID");
type Company = { id: CompanyID };

const company: Company = { id: makeCompanyID("123") };

function joinCompany(_user: UserID, _company: CompanyID): void {
  // irrelevant
}

joinCompany(user.id, company.id);

// @ts-expect-error Argument of type 'CompanyID' is not assignable to parameter of type 'UserID'
joinCompany(company.id, user.id);

console.log(user);
// {
//   "id": "123"
// }

console.log(company);
// {
//   "id": "123"
// }
#+END_SRC

- [[file:snippets/brandedPrimitives.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBA+nARgJwIZgCYwLwwMoCeAtoiADYAUARAiuhlQJQDcAUK1AQA4CmMAQmkwAefgD4cMAN4xkPVBnBkCMANq0hGALoAuATAC+bDtz6D6PDMIAqAGgETc1mADIBm0WOOhIsIqgBrHnNMHFYYGGEfaAcKJD1+RhwxcMjrMQooPWtGBM1LG3txZNSI2FQIGABXMACwEAB3MBgK9wsrOwdjTl4YAFUIHmQASQARSRCMAuhkAEswAHN7KgGhsaovVmi-QJ5VkfHcfyDJ6n31lhNe-ckZWYw9c-Gjdm3qweRHj9uYe71jvYfMbUACMACYAMxMQzdUwwADCICIXHQBDGE3yVhm8yWMCoiORqPWmzeAIJKLAaMOMABp3xSIpVKYbB6fHJqJ+fwRDKJz284BioEJlL07MpnIeNN2YqpoMh0JerAAZjVgFBZuAYAArEDzGVxKofL5rUb2OBCxminmUsa5GAAN11WCkqQA9K7fsg5GQePb0FBWAZ2Dq9daCBRDUMAHT3ewW1ExjCXVjumAAASgEAAtDwAB68NU5r0gZAwACCyAWVSIPDAsBASpgrJgAHIZWMW79KvVyhAILMFmBUIgfU2QDAUWga1AhjAG024S2ni3WCGwPr45TE-ZI8hE8nouQeFGyCAFhGPpdUy7UxEqPcqHoqOCoSmPUGtgKjyezxRNwQrw9G8PTvB8nxfKg30MVggA][Playground]])

* Conditional Types

In /Type-level TypeScript/, code branching is known as /Conditional Types/. The
syntax is very similar to the /Ternary Operator/ we use in JavaScript

#+BEGIN_SRC typescript
X extends true ? true : false;
#+END_SRC

Before the question mark stands a condition. It's always of the form ~A extends
B~, which is how you ask "Is A assignable to B?" to the type checker.

Conditional types only start to make sense when branching on type parameters, so
let's implement our first very simple /Type Constructor/, meaning a type with
type parameters.

NOTE: you can find places where ~IsTrue~ is called a Type-Level Function, I
don't like it, I think it's misleading.

#+BEGIN_SRC typescript :tangle snippets/isTrue.ts
type IsTrue<X> = X extends true ? true : false;

type X = IsTrue<true>; // true
type Y = IsTrue<false>; // false
type Z = IsTrue<number>; // false
type W = IsTrue<never>; // never, why?

export { X, Y, Z, W };
#+END_SRC

- [[file:snippets/isTrue.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAkgzgFQE4FcIB4AaA+KBeKTKCAD2AgDsATOKYVaAfjoagC4oAzAQwBs4IAbgBQw0JEL5YiBunppsgqAHplLNGPDQAmlPjI06HvwiKVa4wM0SAWnpmGKKALYAjCEjOqufK+OgA6vYGGBQQAG4eXmphkUgANFAA7gAWIIyipGAA9kjAUADehInaiTaJQQC+IkA][Playground]])

We check if ~X~ is assignable to the literal ~true~, return ~true~ if it is, and
~false~ if it isn't. With a literal type on the right-hand side, extends
essentially behaves like a type-level ~===~ (Exercise: why?).

Let's try to implement an ~If~ at type-level

#+BEGIN_SRC typescript :tangle snippets/if.ts
type If<C, X, Y> = C extends true ? X : Y;

type X = If<true, number, string>; // number
type Y = If<false, number, string>; // string
type Z = If<boolean, number, string>; // string | number

// Exercise: change the `If` defintion so that the following line will give a
// type error because we want to accept only booleans as first type parameter.
type W = If<[], number, string>; // string

export { X, Y, Z, W };
#+END_SRC

- [[file:snippets/if.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAkgZgHgMIBooA00E0B8UC8USUEAHsBAHYAmAzlMAE4Cu0A-BlAFxRYDcAKAGhInQvARNWaSswC2AIwiM0tJgEtKAcxx8oAen1RZi5cPDQsBWIjgBDADa0IM+UpVQ1jTTr2HPGtrmogBa1hIKAPaRDhB2lK6mHl4+ugZGKdpQAD7GbmYC-gCipMoAxurOPGUAFvFa0MA10AAG8C1Q1BBwmsDqkZSekQx1wCPQcDEOkQDuPlAOmtBzDg5QWuoAbtB2hUYi0MqMkYxQSmV2zM5QM8vxY8DDdmVlEGBjAw4gZ9Gx8fR2eg9RhqBgWKBgOyMOxyCAURgAOmC0AA6uFEABtAC6iXcqkCvnSAW8QQEZDAJzGAG8MNg0CE0GiAL6CIA][Playground]])

** Nesting

Conditional types can arbitrary nested.

Convert ~Direction~ to a number.

#+BEGIN_SRC typescript :tangle snippets/indexOfDirection.ts
type Direction = "left" | "right" | "up" | "down";

// prettier-ignore
type IndexOf<T extends Direction> =
  T extends "left"
  ? 0
  : T extends "right"
    ? 1
    : T extends "up"
      ? 2
      : T extends "down"
        ? 3
        : never;

type _ = [
  Expect<Equal<IndexOf<"left">, 0>>,
  Expect<Equal<IndexOf<"right">, 1>>,
  Expect<Equal<IndexOf<"up">, 2>>,
  Expect<Equal<IndexOf<"down">, 3>>,
];

type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { _ };
#+END_SRC

- [[file:snippets/indexOfDirection.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAIglgJwgY2HA9gOygXigIgBsIAzYfKAHwITgHMALcqggVzAuvwBN0B3TPgDcAKBEB6cVDBJgaCAgC09TOiQjQkKAElM3CAA8A8iQA8AFSiHgEPQGdYiFGiwA+XCKhRL129wdEpOSeUAD8UAAMIQBc3lYGNvY09Ez4IV7hAIzpULE+CX4B7GlepWFQAEw5Xnnxif4EvAIlZaXhAMzVpbGYEABuCqIa4NAA+rhQANohAKIGkKimMwCOrACGhKa6+sZmgWT4rgA0ka7Hs-POS6sbW3qGJqb4tIzkx1CZZ0cXC8DX65ttg89sV3hUvj8risAXcdo8ePxBO92hCALpDTTQOa-Cx1QpQYAIVgQdx4cyiTFQaG3AAaJwAmqSQgAKCyuZkASlw7ny9QcNPKmVylS5viSbM53LiYoa9MFwqqZXChOJOViJA2dggQ0MYDUwCgAG8oOMAL6iIA][Playground]])

** The Power of Infer

The ~infer~ keyword is the real superpower of /Conditional Types/. It enables us
to create a type variable by destructuring the type on the left-hand side of
~extends~

#+BEGIN_SRC typescript :tangle snippets/inferRole.ts
// prettier-ignore
type GetRole<T extends { role: unknown }> =
  T extends { role: infer X }
  ? X
  : never;

type T01 = GetRole<{ name: string; role: string }>; // string
type T02 = GetRole<{ name: string; role: "admin" }>; // "admin"
type T03 = GetRole<{ role: "staff" | "service" }>; // "staff" | "service"

type T04 = GetRole<{
  role: { name: "admin"; permissions: ["read" | "write"] };
}>; // {name: "admin", permissions: ["read" | "write"]

// @ts-expect-error wrong type, missing `"role"` field
type T05 = GetRole<{ name: string }>;

export { T01, T02, T03, T04, T05 };
#+END_SRC

- [[file:snippets/inferRole.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAcTgCVsAbaAHgBVRoAPWaTAEwGdQBvUJFrQAXKACumANY4A7plABfAHygAvHlChmbDtz6DhdcQkwAzZKAAayraAD8N++MzQAbsgDceAsVKMAAwAjBrkVCL0gpgAhgC2YqA8sJBm6F5CIuLJqZjoyioZIEkpaX4kOoEATGEUsNR0UaCxCdmleRnGiQBEMVxxZt0FRWC9-YPlAYEAzLURjUZZoN3JMebmQwA+yzzI7ggAxtBDqiM7sGsboNsre4fHvkQVQQAsc-WR-PZd4tHxPX0BphuhkSJABjweAhsJgeOIANrdGB9LbLOSpDjdAC6yh8p1AxX4LQB42BABoIMgIVCYXDQIjkVxUd10QhMVjfMUAAKwHgoNgkA6wfmQYSQUDomH5J7QCnUtKgAAGSJE3UVoHMSBoXEmlQArO8Ggw-q0Srl8qdfALcLABJVghSglVHTMXS8XQalD4gA][Playground]])

We can destructure every structure known ad Type-Level, see later for more
examples on Arrays/Tuples and Strings.

#+BEGIN_SRC typescript :tangle snippets/returnType.ts
type ReturnType<F> = F extends (...params: any[]) => infer R ? R : never;

type Fn = (name: string, id: number) => boolean;

type T01 = ReturnType<Fn>; // => boolean

export { T01 };
#+END_SRC

- [[file:snippets/returnType.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAShwFcBOA7AKuCAeAYgPigF4ocoIAPYCFAEwGcoAKAOlbAEMl2BbOgLijsUIANoBdAJRECASxQAzCElhQA-CoEoIANyUBuAFAHQkEiiJMUPCALrAkcgOYAaKDJqaE3AEZKphAm8AeyCAGwghQ2NMKDQABgBGCzhEVAxIXBQ8PSgAelzpKGCwiJQjCjAgpGAoAG9YxKgAX0MgA][Playground]])

Even custom generics.

#+BEGIN_SRC typescript :tangle snippets/destructureGenerics.ts
type Container<T> = { content: T };

type Contained<T extends Container<any>> =
  T extends Container<infer X> ? X : never;

type T01 = Contained<Container<string>>; // string
type T02 = Contained<Container<[boolean, number]>>; // [boolean, number]

export { T01, T02 };
#+END_SRC

- [[file:snippets/destructureGenerics.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUB8UAvFAN5QDGiwESAXFLlAL4DcAUO6JLNWhgBM8UCAA8aCAQGdeSflmzIEIfISLsojEeNrTZKdAvQAzLFAAahAPwWoDDADcsHLuGi4ADAEZi++UPg5QxwpYEx0AHNVVigAelioUPCECNceTwAmX0CDQWwc+RwAbQAjODgAGwglABooBABXAFsSrABdaLiE0vKq2vrm1sw2zjEwOExgMkZvOsyWDiA][Playground]])

There is no standard syntax for declaring block-scoped variables at the type
level. This is a shame because we know how much more readable the code can be by
declaring intermediary variables with sensible names. It can also help
performance, we can store the result of an expensive computation to reuse it
multiple times later without having to recompute it every time.

But we can use ~infer~ for that.

#+BEGIN_SRC typescript
// Good âœ…
type TwoTimes<X> = ExpensiveComputation<X> extends infer R ? [R, R];

// Bad ðŸš¨
type TwoTimes<X> = [ExpensiveComputation<X>, ExpensiveComputation<X>];
#+END_SRC

** Advanced Gotcha: Witnessing

A (probably) surprising result

#+BEGIN_SRC typescript :tangle snippets/withoutWitness.ts
type Some<T> = { _tag: "Some"; value: T };
type None = { _tag: "None" };
type Maybe<T> = Some<T> | None;

type UnwrapMaybe<X extends Maybe<any>> = X extends Maybe<infer T> ? T : never;

type T01 = UnwrapMaybe<Some<string>>; // string
type T02 = UnwrapMaybe<None>; // unknown ??? ðŸ¤¨
type T03 = UnwrapMaybe<Maybe<string>>; // unknown ??? ðŸ¤¨

export { T01, T02, T03 };
#+END_SRC

- [[file:snippets/withoutWitness.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwgHgCoD4oF4oG8oD6wAhgOYBcUARPElQNxQBuxANgK4SWpQC+9AKFCQoAOTgA7aDnxEylKuKlU+g4dACyxEACMUGbLET7MAHzGSIgoeGgBVCQHcATsTBbdKABpQIAD2AICQATAGcoDz1kYgkQdEwcH39AkPDIlABLCQAzCGcoAwB+AqhKKSY863UCgAYARkMHFzd05FoUUOBnLNJ4xgB6fqhO7olSGxFUGoAmRqdXd20opQh0AaH2CQBrCThHCShCo6hAPg3ACl2J6CmAZjnmxc9kVpGevqhBqE2dvYOj4vOBAJ-GA4M5gHhanUADS1aYwm6qARAA][Playground]])

This is because the Type Matching (aka Type Destructuring) worked (otherwise we
would have got back ~never~) but the inference (keywordd ~infer~) failed because
there's no type witness in the type structure, meaning there's no place holding
the type information.

#+BEGIN_SRC typescript :tangle snippets/withWitness.ts
type Some<T> = { _tag: "Some"; value: T };
type None<T> = { _tag: "None"; _witness: T };

// NOTE: you can always populate this value with `undefined as T` placeholder
type Maybe<T> = Some<T> | None<T>;

type UnwrapMaybe<X extends Maybe<any>> = X extends Maybe<infer T> ? T : never;

type T01 = UnwrapMaybe<Some<string>>; // string
type T02 = UnwrapMaybe<None<string>>; // string
type T03 = UnwrapMaybe<Maybe<string>>; // string

const none = <T>(): None<T> => ({ _tag: "None", _witness: undefined as T });

const noneString = none<string>();

type T04 = UnwrapMaybe<typeof noneString>; // string

export { T01, T02, T03, T04 };
#+END_SRC

- [[file:snippets/withWitness.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwgHgCoD4oF4oG8oD6wAhgOYBcUARPElQNxQBuxANgK4SWpQC+9AKFCQoAOTgA7FBmx5CJCtXFSGhAO4BLYFIDOO7n0ECA9MbEB5VAFFKIOOygBjYhKhs1xEDqhg4YdqzEwNDAABYa3iwc0JphUAAG7BIAJhAAZhpSyW7eqPE+gY4QoXCsqQBOQuDQALKeAEbSmDi0TVAAPmKSTUbC0ACqEmrlxGB1II3IABpQEAAewSne45MuIOjNUDPzi8nLDSiZaRDlUDIA-GdQlFJMJ73VZwAMAIyyg8OjKyityDrA5UypA2jFMUH+gIkpCqIlQTwATO8hiMxgdkMoUBCgSCoGCsVCYdA4QBmJGfVETFDfP4A7HoUFmfHQgSOST-KASbqyNDoAAUAEpKBiedhMLz8EQyJQqBiqAAadRaXT6KBJVIZLI5K68flGVkSdmcqQwWlQ2RGzGm4ECh6wp4AFjJKOpfTgaQ53RNkOBDPBVoEAnmvnKwDkcJeCrh8MjT2JMcd-AEQA][Playground]])

** Exercises

#+BEGIN_SRC typescript :tangle snippets/inferName.ts
// eslint-disable-next-line
// @ts-nocheck

type GetName<X> = TODO;

type R01 = GetName<{ name: "Gabriele" }>;
type T01 = Expect<Equal<R01, "Gabriele">>;

type R02 = GetName<{ name: string; age: number }>;
type T02 = Expect<Equal<R02, string>>;

type R03 = GetName<{ age: number }>;
type T03 = Expect<Equal<R03, undefined>>;

type R04 = GetName<{
  name: { firstName: string; lastName: string };
  age: number;
}>;
type T04 = Expect<Equal<R04, { firstName: string; lastName: string }>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/inferName.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoAOLhEAOUwBbcAB4AGgD5QAXlAAVAPIARTQG5ufQaABKABgCMqkWMkzZAb1Dxp4AFygARMJwAnWOB4nqAAvooGRkLqltYAokSCTIiysQCOAK6Y0LLmFgA0Xj7Y-oHgnorhhgJC5gBM1qISro7Orh6QiP7wAOZ6oJjd7s7pUtjgvqGVkRpm9Wrxiclpmdl1BR1d3RUGPNWmZgDMDbbNTgND8CNjE2ERe9FH8wnsSxlZOYcF6fCo4ABmCHAqG2VWM5gALMcmvYHORQK0ZB4nADfB07EMNgheqBoJg0W1QJieqEDPDzh5LqNxgZbrtjNFIU9Fik3qszOCCsjYKjoRjOli+rj8YjCfziWFKnSojpNNZCAA3alS0ALF6ydQQEjgH6QUCddLgZRqdR3YzLd7yAoATSNcNAAAp1Yp7QBKVTKDXERDa1C6+SgAD8oCsHlqbq9Pt1Ttd7o0mu9OtAVsDwdAobt8KD+vAGbToD+WUg4B2xH4DF8iFATmi+RmtQKDwb7IbMpJ5CAA][Playground]])
- [[file:solutions/inferName.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBA4hwDkCGBbCAeAGgPigXikyggA9gIA7AEwGcoBvKC1CALigEsKAzCAJygIoAXygB+QVHYBXahG5cIVANwAoVaEhQASgAYAjPljxkadI2Zp2AIhhIARnw4QANhGsjsazdAAqBowBREkgAY2B0QIBHaSQXdD19ABooWwcnV3dsL3UfHV0AJiM4RBZzJhZ2GmAnCgBzZSgkOrYmaRR7fk9vcD9CoJCIcMiYuITClOrauuy1DV78gGZikzLGZtaKds6BYRy8-2WCYLCI6Nj4vUWU2Sp5RSpZ3IW9ABYV0rN6VSgKqwYoAo+NVTK0plwGlAXEgQZUoOD6iI1L8Nuwth1+Go9j0tP53sdBsNzmM3ilGEDYf8EZDoZSwTUIZ4cvNcQB5AAirKMFAgADdMSzoCchhFfMQyJRaFAatIILgCL4cULRvFMCkAJryn5QAAU6F82B1AEp8LgxaRyNQ6EQJIZ2AUTRbJXR9YaTXgzeLLVL1eIoHaoAVtb8JDKIMGpIC4jQIHNSGAAPZ8YAA-zJKD+AopQ7Z3SvbMcrnCNRAA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/and.ts
// eslint-disable-next-line
// @ts-nocheck

type AND<A, B> = TODO;

type R01 = AND<true, true>;
type T01 = Expect<Equal<R01, true>>;

type R02 = AND<false, false>;
type T02 = Expect<Equal<R02, false>>;

type R03 = AND<true, false>;
type T03 = Expect<Equal<R03, false>>;

type R04 = AND<false, true>;
type T04 = Expect<Equal<R04, false>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/and.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoAIIA5ACIAeYQBpQAIQB8oALygAKgHlxmgNzc+g0ACUADAEZVIiZMQAnAK7g59p4v2Gh6i1YCiRQSZESV8ARwdMaEkzcxdHcEV3AwEhMwAmKzEpADNIyGdQXOh8pM8NUwy1f0DgsIio9LkikqSeFJNTAGZMm1cC5oSPdu9uqoD2WvDI6K6mvITWsrMAFh6c+bi3IaNvVbGakKmG02W54oX9Np3tTStCADdwO22haonJdQgScHhUSFA+so1OoXqA6tMABpyACaQPIoFAAAoPopEQBKVTKT7ERA-P6gCGgAD8oEsAC5QGkMTi8f8UejMRovrjfv9ocTSaAKWl4QiOX1eQiKQNLsR+Aw7IhQABvcqxcppOQjJUnJU3UAAX30QA][Playground]])
- [[file:solutions/and.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAggcgEQDwwDRQEID4oF4oDaamAulBAB7AQB2AJgM6HABOArhOqx2QPxTdoALigAzAIYAbBhADcAKHmhIUAEoAGAIx5YiJIK7sIWBcugAVLToCiFSAGNgSawEc2UpBs2GOWE4rM1dQAmHXhkCWlOMSkZf0DLUPxbBydXd0lPEPRIuP8lcGgNAGYwvQMYqPjCqEtS5LsIR2c3DxKc2ON8wI0AFjKIzp9jUxrLfobUloys3o6q7rGAeQQlnRoIADcIFlGVFKanc3IqWkYBIxx8cz3odI8ADXQATSv5KCgACiRzLE+ASjwOGOlGo9CYDyg-G0ImCgNBZyYPz+gNwwJOYPOzyhUBhUGC7w+OMEhI+IlyckUlDAAHsWMAoABvWpadCJNnqYocua1FZrAC+CiAA][Playground]])

* Objects & Records

What can you ask to an object at type level?

#+BEGIN_SRC typescript :tangle snippets/objectKeysAndValues.ts
type User = { name: string; age: number; isAdmin: boolean };

type Age = User["age"]; // => number
type Role = User["isAdmin"]; // => boolean

type NameOrAge = User["name" | "age"]; // => string | number

type Keys = keyof User; // "name" | "age" | "isAdmin"

type Values = User[keyof User]; // string | number | boolean

export { Age, Role, NameOrAge, Keys, Values };
#+END_SRC

- [[file:snippets/objectKeysAndValues.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAqgzhATlAvFA3lAdgQwLYQBcUcwiAllgOYDcUOVR2ArngEZJ3lwCCAJnkrE2AexEAbCDixQAvjQBQC0JCg9GqWAkQBtAEQMIegLp0A9GdQA+FuyTLw0AEoToaeEn3d+grCfOWKDairtJKKtAAcvgQAPKI6m5annq4BHpQAD5QBoz+UBbWJGSUVFm2HIjhjlAA0hAgcJoA1g0iAGbJiAE5aUbluf3Zet4ClHrVqgBqOOLMEE3u2jqtIB1dpgWWpBTU5VisleUhkmEKEAAeYCKIwBhqjAA0UC6Sz9EE8YnP9Y3PM3MFnJFEA][Playground]])

** Subtyping and Constructors

#+BEGIN_SRC typescript :tangle snippets/objectSubtyping.ts
type FirstName = { firstName: string };
type LastName = { lastName: string };

type AllOf = FirstName & LastName;
type OneOf = FirstName | LastName;

const r01: AllOf = { firstName: "Gabriele", lastName: "Lana" };

const r02: OneOf = { firstName: "Gabriele" };
const r03: OneOf = { lastName: "Lana" };

// FirstName & LastName is subtype of FirstName | LastName
const r04: OneOf = r01;
// FirstName & LastName is subtype of FristName
const r05: FirstName = r01;
// FirstName & LastName is subtype of LastName
const r06: LastName = r01;

export { r02, r03, r04, r05, r06 };
#+END_SRC

- [[file:snippets/objectSubtyping.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYglgJwM7AHIEMC20C8UDeUAZoihtgFxQoJwB2A5lAL4DcAUKJFADLplZcBKABt+aQVRr0mbdp3DQAgiJEB5IlDzxkE7FABkvceQgcu0NXQgatsUnugAfYwOwd2AYwD2dFFAQABgBGKhV1TTxCEl1TKgAiAHF0ACNaCBEIeIAaURNJKHi+OnR4lg8fP2AAwIAmKisbSOEYtwgE5LS4DKzyr19-IIBmButbKLy2hOLSvvYAenn7WMFDV0coOCRqAFcUiyhvTR02qBc+Nv6qmoAWUaa7IOCOReXTowuNrd39xUPj2iXSqDQIAVioJw2eCeLyWkNMa0+CO+SD2ByO61MVxBADYqEjVtCQh4IAAPMDeBDVQhBWq5Yb0wI3Rmgxk4vpAA][Playground]])

** Records

The definition of a ~Record~ is the following, where:
- ~K~ is considered as an union type
- ~Key~ will iterate over every value in ~K~
- ~V~ will be the type of the values

#+BEGIN_SRC typescript
type Record<K, V> = {[Key in K]: V}
#+END_SRC

#+BEGIN_SRC typescript :tangle snippets/records.ts
type FromStringToBooleans = Record<string, boolean>;

// The same as
// type FromStringToBooleans = { [key: string]: boolean };

type RecordOfBooleans = Record<string, boolean>;

type InputState = { [Key in "valid" | "edited" | "focused"]: boolean };
// { valid: boolean
// ; edited: boolean
// ; focused: boolean
// }

export { FromStringToBooleans, RecordOfBooleans, InputState };
#+END_SRC

- [[file:snippets/records.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAYgTgewLYGVhwJYDsDmAVBAIQQQBsIBDLAZygF4oAlCAYwTgBMAea9bHADRQARiXJUAfAG4AUDID08qHgAW0ahSTQK1BUtCRYiVH1wFiZSjXpQA3lADaAawggAXFF6ZcAXQ+jLKigAX1kZA2hmNk4AeQAzC3FrBij2bi9+IQCk6TkIqABJLDAAV2A0CmBoBnsHAGlXKGwoACIANwpSDA4WqAAfVogODCqe-ta4hBYS6iGWvxExKxDZRTsoDq6OfyWqPSgpKCGRoZ3ArH3DyenZ7cXz-eC5CAAPMHZgdfhkNG98Il2NCEqViCUB1CERVK5WAlWgoRkQA][Playground]])

** Exercises

First look at [[https://www.typescriptlang.org/docs/handbook/utility-types.html][Omit, Pick and Partial]]

#+BEGIN_SRC typescript :tangle snippets/optionalId.ts
// eslint-disable-next-line
// @ts-nocheck

// Combine Partial, Omit and Pick to implement MakeIdOptional

type MakeIdOptional<O extends { id: unknown }> = TODO;

type R01 = MakeIdOptional<{
  id: number;
  name: string;
  age: unknown;
}>;

type T01 = Expect<Equal<R01, { id?: number } & { name: string; age: unknown }>>;

type R02 = MakeIdOptional<{
  id: string;
  title: string;
  content: string;
}>;

type T02 = Expect<
  Equal<R02, { id?: string } & { title: string; content: string }>
>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, TODO };
#+END_SRC

- [[file:snippets/optionalId.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrcysAYQYC22BOFAAFTACdEsTNAA0oAPIDYiUJnipxsTqEQNQsAQAc8A8ElABZTB3ABJVEpMyG8Od0QBPE6Nv2Ti5uHtAAPEoQJJaokKAA3kaoAFygAK7wHPAMAO7woAC+AHygALygACpKACJKANxevqIASgAMAIxlNnaOzq6w7nJh8eSgSanwaULgkg1jHhapkIiSCADmcxpr4KkZWbnwDcUN5D5+lR1dAKJEfkyIYVcAjmlDbe2KibCoAPwTU9gZoVQAAyBKgBY7UDLVbwDZbKF7bJ5QpFIonM4tVoAJi6AV6wQGoWGo3G0JW602MkQeCWFLhmyY7kQlkQdNhG3Ix0a5wqOOut3YD1Jz1e4Ta2M+ST+5I5wLBiWptNllNATKQrPZ61R5HRPNEVVqXUIADcZg1MaAbncHhUoiytHEVmlwCVyhULU0rS8hgANRQATTdpIAFGEKkUQwBKMolO3EB2xUC+0A-UCdVLYmMJmJxcORmOlOP23OgAOp9OgTOksZp53gGtV0AAMzkkHAJ2IJgY0nBfI+F0llRqkQKDSAA][Playground]])
- [[file:solutions/optionalId.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/PTAEGEHsFsCMEsB2BTUAFAhgJwC7wwDYA0oA8tPDqBogCbrwDGA1qDpKPNAA4HLTJEVALIZmyAJK1S3PJESEAUIpChuWZDjzIsAWngBzRJA2KcAT26pR4qTLkKCAHlKhkADxyDaAZ1ABvTloALlAAV0RmYwB3RFAAXwA+UABeRVB0bDxCJzQmZhcSACJ4WiLE5IAyMgocQtASssSAbmULK1AAJQAGAEZU0BtJaVl4eRz-dKDQxDC4HVaMhQFQnxwsJANF6gNkUIioyFjWpNazS1QAFT6BgFF3K0Y624BHMJye3pJA0oB+GbmsB0CVA1UCyz2oDWG0QWx2kIOMTiSRabQuXW6ACYBkM7KNxs5JhlSqt1pttngcHxSTCtlNGPIvEIaeTFKc0R1rtiUqB7o86lNXu9nD1Md8gv8oWTYSCwWxKNSpbTmqAGUJBDgWTKkopUedOaQACKuHkoABuC31qD5yCeTkubk83j86zCyGSPMurXa1reOQAGiQAJoeqYACntiTDAEpUskHR4mb5QP7QL9QP1QpjY4nnaBIzG46AE066H4g2mM6As1MMunXcha9XQAAzQg+ZBnDzcExUQLXL7FrEkS5G1zxVpAA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/assign.ts
// eslint-disable-next-line
// @ts-nocheck

// Implement at type-level the same behaviour of `{...a, ...b}` at run-time

type Assign<A, B> = TODO;

const assign = <A, B>(obj1: A, obj2: B): Assign<A, B> => ({
  ...obj1,
  ...obj2,
});

// Override `id`
type R01 = Assign<{ name: string; id: number }, { id: string }>;
type T01 = Expect<Equal<R01, { name: string } & { id: string }>>;

// Override `age` and `role`
type R02 = Assign<
  { name: string; age: string; role: string },
  { age: 42; role: "admin" }
>;
type T02 = Expect<Equal<R02, { name: string } & { age: 42; role: "admin" }>>;

// No overlap
type R03 = Assign<{ name: string; id: number }, { age: number }>;
type T03 = Expect<Equal<R03, { name: string; id: number } & { age: number }>>;

// Using type inference from values
const R04 = assign({ name: "Bob", id: 4 }, { id: "3" });
type T04 = Expect<Equal<typeof R04, { name: string } & { id: string }>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/assign.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrcysASQFsADnn7gkoTIlCIAnoPx4AbuGjS2oLKNDZwLTItgMArgCdQDAGagABgG8AdI8wAaUI-vYAvtYlSTR+GREWFFuWXlQAEFISFgAc3gAHkjXACEAPlAAXlAAFQB5ABF8gG5uJgZ4SClMGPj4bNBktPSACgZsACsARgAuKNcOzoAmftSASn7o2ITm0AzszNbbclA3RyHu51X1+yHh7c9xsp5QfOUTE1hUcBtr63Jw24AlAAZuxun6xNtQeExRP1qld4HESqBrv14EZ+DozJ5XL9IRpECC4qBPOkyk88u9GgBRIjyJiIRL4gCORkw0ESby2oF+-0BKLRGNAADIGRDUEDUQh0ZisdwqOdwJdrrdrJg4uAfJh4KgbCYGHgHji3sNPnVZjtGQDwLy0eDpQaWfzwcq8Ib+Rjtmtfib+gAWYYWlWmgBEmFQ-AQHox5CFONyr01OUJxNJFKpNI1iL++utoLZnIdMudrtAls93t98H9gpOVAAcgxzBdoJhBI85C9XgBmLUzJJ65nA83cqEwuG2rmOv7dsUYoO13GN8NE9hRynU2kN+NM03t0Hg5HQ2FDzwcvvpgcb+HpIWnACqsWTOIQFjFYiYtwsyv4oEU1KMUHIFSqUjeTsatWbywTZkPVSDoPVcZEfwRLlkQ9esC2OGsIhDH8J0jMkZxpJ5LFAb8F0TM1ky3VNOwIgVDxOYMinyRpCAubFRwjKdElyCASDEVBIGkfxwEyHJcnoiJo1nAANVwAE1eJ2VpmLacZFjyVjEHYzjhNAAB+UAPn6YY5OIJSFU4mTWjkrJMhYvTlNAMT1M00BtJ2NYNNRV8HLs0ALGpSBwBOYhBAYEwpF+EN6RDA4x1cZCIqojEyiAA][Playground]])
- [[file:solutions/assign.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/PTAEEkFsAcBsFNLwHYBdQEN2oJ7XgLQIBu8soqAFvKAM4ZKgBG8lGxAlgPYCuATqC4AzUAAMA3gDppGADShpkpgF9RmdHx7ICqDkgBQ+3PlABBWrQ4BzZAB5T8gEIA+UAF5Q40AG0A0qA5kUABreBxhUAB5SA5Ue3lQ8JEXAF0ALjM-FNBlUAAyUEcAbkMAYy5kWnQMC2sgj3jC5wAKLiYAKwBGDIdBDoAmDMcASh7am0aXd1dm8X1QBWk2rtl5xcll-tXlYZL9ECjSPj4OABMaUTPRIzwaACUABk73M3G7L2QGeAyqk+QrIoBU4ZZA8SAsATKeReM4-VB-Kw5ZwlYw0AAqTxeAFEAB74UpxLEARx4GFgtkenWhoE+SDhCJy+U8QPpgURymcyMMB0iRxO5zEGCs8DUGGQpzEfC4CGuqNAj36L3Mlgmaw+X1Z-0BQu+dHhbMBUoQmvZqwWXh1GQALP1DdLdQAiDCnGLIB05fRcuUYxUeXH4wkkskUh5bZm03W-NmMgoW4XW22gI2O52u90crn7MAAOS4giOsAw0BuJkeAGYlW9bOq6XqEYDYTSwRCctTLU3wfBIV7bqAMRW-Xj4ATbMTSeTy9SIyaG8COy3crHMPH512kZmDgBVSz-Ci9wJCLsoUo0IRSyCgYhknjwWj6cqVdCPK0vGoq5CzGka0AOxxtB3yI2L5QsyjYOmW6a7CW6IPC+g4BqOQbkqiETPlO35Rrui6gXOmHspyezepEAAikQvMg8BHCivb+sOcRoqA8A4qgKCnLQFCaPArgeGi1EmGOwYABryAAmtxazNLYaItMM0x9oxzGsexgmgAA-KAzwZP0slMSx4rsVJMlyQxulKaAIlqRpoBaWsCzqfCN62dZoBCGStDwHsTHQFwfDoF4GJUn2obyP2IWwSFJFkcoJRAA][Playground]])

* Arrays & Tuples

** Arrays

List of an unknown (at type-level) lenght of value of the same type. All of
their values must share the same type, but since this type can be a union, they
can also represent arrays of mixed values.

#+BEGIN_SRC typescript :tangle snippets/arrays.ts
type Tags = string[];

type User = { firstName: string; lastName: string };
type Users = Array<User>; // same as `User[]`

type Bits = (0 | 1)[];

type Content = Tags[number]; // string

export { Tags, Users, Bits, Content };
#+END_SRC

- [[file:snippets/arrays.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAKghgcwM5QLxScATgSwHYIDaAugNwBQ5okUAqkhFmlAN5QBmOWmAcnALYQAXBmz4EpKABs4vAcNG4CUAL4Vq0eoxToAglixwQAHi1YAfJID0VjPKiyoAAzMknlDVABCOYDqgAFAAMUAA+UACMAJQkFFTg0ADCAPZ4wBBpzPDIhHgArvwARoxkUDaK4pQQAB5gyVjArLCISAA0dAzc7T5+7SlpGY1q5EA][Playground]])

** Tuples

Tuple types are arrays with a fixed and known length at type-level, each index
can contain a value of a different type. For example, the tuple ~[string,
number]~ defines the set of arrays containing exactly two values, where the
first value is a string and the second value is a number.

#+BEGIN_SRC typescript :tangle snippets/tuples.ts
type SomeTuple = ["Bob", 28];

type Name = SomeTuple[0]; // "Bob"
type Age = SomeTuple[1]; // 28
type NameOrAge = SomeTuple[0 | 1]; // => "Bob" | 28
type Values = SomeTuple[number]; // "Bob" | 28 | true

// Can be concatenated
type Tuple1 = [4, 5];
type Tuple2 = [1, 2, 3, ...Tuple1]; // [1, 2, 3, 4, 5]
type Tuple3 = [...Tuple1, ...Tuple2]; // [4, 5, 1, 2, 3, 4, 5]

export { SomeTuple, Name, Age, NameOrAge, Values, Tuple1, Tuple2, Tuple3 };
#+END_SRC

- [[file:snippets/tuples.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwgFQK5gDbQLxQNoBEAQnAEYEA0UATABwC6A3AFDOiRQByAhklLvCRpMEPAAYmUAPRSoxMgTbhoAQQDmOWIhToseAIySZNWko48kAeQBO6zYJ0jxUAD5RDjabOwA+OSXJXEzNoADVuDFQIAGd+LSFdUQA7VARSCGsjWXlAtzog4Gso1mMAYW4kqHSoAGM4JJruYAgkpogAExCoYSx9OLwAFioAViYunohqfv0qaioAZioAOhWJjy98GZoFqiGoUfHE+f6VpbXl1cTqLPw94aotuahFqDv6VggADzA4a2AoADe8UcWCoFggVDsYN4EBsUKg4UiMSo526VxRRygAF8WEA][Playground]])

** Destructuring with Infer

#+BEGIN_SRC typescript :tangle snippets/destructureArraysAndTuples.ts
// prettier-ignore
type SwapTuple<T extends [any, any]> =
  T extends [infer X, infer Y]
  ? [Y, X]
  : never;

type T01 = SwapTuple<[string, number]>; // [number, string]

type DropFirst<T extends any[]> = T extends [infer _, ...infer X] ? X : never;

type T02 = DropFirst<[string, number]>; // [number]
type T03 = DropFirst<[string, number, boolean]>; // [number, boolean]

type Partial<T extends any[]> =
  T extends Array<infer X> ? Array<X | undefined> : never;

type T04 = Partial<string[]>; // (string | undefined)[]

export { T01, T02, T03, T04 };
#+END_SRC

- [[file:snippets/destructureArraysAndTuples.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAZQHcBDcAFQFdwAbaAHltGgA9ZpMATAM6gA2lUyEANKHGEAugD5QAXjyhQHbrwHCRCTADNkoABrT9RyKACactaAD8o69JN31ALlCZoAN2QA3HgExKS0AAwAjCrk1HSMLKwigrCQ+ujSmPQAtgBGyIoBoCCiWXnI0ilpmOh2ISSgACKQ2OAAYgiQKeycPHxCMhIiijGafTqiFsYA+tIAdAtTVm6OpqBePv6QQfVh4QBMMc2tHV2wSVXpmTn5kIXFYCJlt3ZEDREAzEct7Z3dyakrt4bhVQLlsNgWOJ7iUniDINJwZDoNDgm9SAAFKiQRBUJg9LT9YSyYZKVTqMbaAYAQUgkCohFYS1MSictPpjJMoAAPqB6AJoAZ9NB+EoNn5AmjQhpwgAWGJYnEIPGsS41UlFEoACjV6B5fIFQp8-AAlMNgtxwLhYKAAN4yyLSCL7J3hD6u+UAXyCQA][Playground]])

** Exercises

#+BEGIN_SRC typescript :tangle snippets/tupleToArray.ts
// eslint-disable-next-line
// @ts-nocheck

type TupleToArray<T extends any[]> = TODO;

type R01 = TupleToArray<[1, 2, 3]>;
type T01 = Expect<Equal<R01, (1 | 2 | 3)[]>>;

type R02 = TupleToArray<[number, string]>;
type T02 = Expect<Equal<R02, (number | string)[]>>;

type R03 = TupleToArray<[]>;
type T03 = Expect<Equal<R03, never[]>>;

type R04 = TupleToArray<[1] | [2] | [3]>;
type T04 = Expect<Equal<R04, (1 | 2 | 3)[]>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/tupleToArray.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoACoBXfnmEMAggCdZmXgB5hEEuHipIoTPF4BtALoA+UAF4RAeQAilgNzc+g0ACUADAEZzI8ZJnzFJX0PABpQACYwgGYTBychYU9vAFEiQSZEJWSAR1FMaCV3UNAACi8AHwjQSqiASiNjYwceASF3cO8xCXApOQVlfXhRAFtscFkwyERZBABzWJbnRI6LVPTMnLyC9rCSodHx6tApmfhZ+pMmx1bXNyjO3x7-fqCF+JE7lLT2Ddz8wruYUIADdxg0ros2m4ACwPbq9AIDDyGI76cIoyr6GJXd6JWGrb4ZLJ-bYw3YVKo1C6NZq4myWbwg8ZxG5rH4qNSIDRaUDTUTgUwWYQs5ybf4ADTCAE1BeRQKUVMYSrVzKZVMQuZptOLQAB+UBeABcERVGu52kVytVIk55tAUr1BtAxvCcvljr54Dd8uNADN8pBwM1iPwGLJEKAAN4fYrLMKJKLxslWWygAC+DiAA][Playground]])
- [[file:solutions/tupleToArray.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAKgrmANhGB7AggJ0wQxAHhiggA9gIA7AEwGcocKQBtAXQD4oBeWJiuAWwBGETC1YBuAFCTQkKACUADAEYusBMjRZcBJsoA0UAEyGAzOymzoMFWoCiJSAGNg+OwEc4ORPiUGoABSqAD7GUKGmAJSsbGxSMuDQSkZq8EgoGNh4+LwCwpiGNMCYAJYUAOYWCXI2KdwOzq4eXj7JhgF8QiLhUEWlFdHscdJWCoqmqRoZ2tkxlomw4-aOEC5unt6+44YUEABuIjHD1UmKACyT6VpZusosPUxG96FM5sOjNhf1K2vNm0pndohMIRQaxeIfADyABFIWpdgdMPM5A1Vq4iKRyNQ6MU4BAONwYMjoH8fAANQwATQJkiggUIbACkS4HAxZEotCgZKgAH4oKoAFzGZmYjl0BlMlmwYjs7FQSm8-lQIVGWl0xW4iBqulCgBm3hoEHipDAqEwwCgAG9Fv5aoYbKZ7ed7TC4QBfKRAA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/last.ts
// eslint-disable-next-line
// @ts-nocheck

type Last<Tuple extends any[]> = TODO;

type R01 = Last<[1, 2, 3]>;
type T01 = Expect<Equal<R01, 3>>;

type R02 = Last<[1]>;
type T02 = Expect<Equal<R02, 1>>;

type R03 = Last<[]>;
type T03 = Expect<Equal<R03, never>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, TODO };
#+END_SRC

- [[file:snippets/last.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoADKZIiADwAVAK788EEuHipIoTPF4BtALoA+UAF5QUgPIARUwG5ufQaABKABgCMRkWMlaXAGlAAmPwBmfRs7ISlXdwBRIkEmSWiARxlMaAlnX1AgvT0bHgEhZ393UXEJb1CC+0iS41j4xJS0jKdA0Bdc-PDHJyDSzwqqnsj++rj2JtT05yC-QgA3cAAnLttCkwtTd0WVsI2GyelFRGVVUERlmXADYyl9+2TpiQANPwBNW-JQUAAKaT0vwAlEYDFITmc1C9QAB+DqgABcARBxFOKjUAOBoJMEPRoHesPhSP83x+hMu11JPyRADM0pBwPliPwGMtEKAAN4mVx+Wq8vq8ragAC+NiAA][Playground]])
- [[file:solutions/last.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAGQEMBnWAHgBUBXcAG1OgA9ZpMATK0BUyEA2gF0AfKAC8eUKCat2XHv1AiAdFoSYAZslAB9ADSgd+yKAAaYuaAD81uwC5QmaADdkAbjwFipABKAAwAjDLk1HQioaYATKYAzJK+RCQKYREAohwkAMZ0WQCOjBQstCGxoIkSEr7+6SFxEZQ0tDEpDaT0wc3SoDn5hSVlFb2mobX1aUHBiS1R7Z0zGfP9g9AFtMWl5SGJpu5ekFN+K-QA8gAiFxFHPl0DuZt09KCc3HwCsJCM0FL9eipAIDEblKymACaALsAAoGBJYQBKGRSN4fVQCKwOUDhVxxFEYr6gBHI1EKd4qYmQnF40BxOzyRw-P6M0CuXRlKjQeqccC4WCgADeGSqPQSq1MlxuoAAvr4gA][Playground]])

* Recursive Types

To loop over types we will use recursion.

More or less the pattern is always the same:
- Destructure using ~infer~ the original type by naming the "first" piece and
  and the "rest".
- Do what you have to do with the "first" piece.
- Use recursively the same type with the "rest".

#+BEGIN_SRC typescript :tangle snippets/tupleToUnion.ts
// prettier-ignore
type TupleToUnion<T extends any[]> =
  T extends [infer H, ...infer T]
  ? H | TupleToUnion<T>
  : never;

type T01 = TupleToUnion<[string, number]>; // string | number
type T02 = TupleToUnion<[true, false]>; // boolean
type T03 = TupleToUnion<[]>; // never

export { T01, T02, T03 };
#+END_SRC

- [[file:snippets/tupleToUnion.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAFQFdwAbaM7AVUwW0wB4zRoAPWaTACYBnUAENMhANoBdAHygAvHlDkuvfsNCSEmAGbJQACQA0oAHQWd+yOWnLQAfiOgAPuSq16TFuzKz7AFygmNAAbsgA3HgExKRkAAwAjIruNHSMzKxskkKwkDroppgUALYARshyEaAgoLn5mOiuwaUVkDEk5PEATCmUaV6Z7JJ5FNCmuqLUQtBVNWBl2Ni04h1x8QDMfR7p3lkystW1IeHteDzguLCgAN5diaYJ3Y+boAC+UUA][Playground]])

** Tail Recursion

The previous example it's corrent but it'not tail recursive, and for that it
gets [[https://herringtondarkholme.github.io/2023/04/30/typescript-magic/][penalized by the type checker]], to ease this limitations we can turn it
into a tail recursive implementation.

#+BEGIN_SRC typescript :tangle snippets/tupleToUnionTailRecursive.ts
// prettier-ignore
type TupleToUnion<T extends any[], R = never> =
  T extends [infer H, ...infer T]
  ? TupleToUnion<T, R | H>
  : R;

type T01 = TupleToUnion<[string, number]>; // string | number
type T02 = TupleToUnion<[true, false]>; // boolean
type T03 = TupleToUnion<[]>; // never

export { T01, T02, T03 };
#+END_SRC

- [[file:snippets/tupleToUnionTailRecursive.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAFQFdwAbaM7AVUwW0wB4zRoAPWaTACYBnUAENMhANoBdADSgASqAC8oTNABuyAHwq8ocl179hoSQkwAzZKAAS8gHROL1yOWn7QAfnJVa9JhZ2MnklAB87bU8ALkUAbjwCYlIyAAYARhVfGjpGZlY2SSFYSAt0eUwKAFsAI2RpbTjQEFBi0sx0UAjK2uQkknJUgCYsyhyA-PZJEopoeUtRaiFoBqaWmuxsWnF+lNSAZlG-XMCCmUbmsHUtSESecFxYUABvQfT5NKGPg9AAXwSgA][Playground]])

** Exercises

#+BEGIN_SRC typescript :tangle snippets/unwrapAll.ts
// eslint-disable-next-line
// @ts-nocheck

declare function all<
  // `P` type parameter as a tuple of type `Promise<any>`
  P extends [Promise<any>, ...Promise<any>[]],
>(promises: P): Promise<UnwrapAll<P>>;

// It must work with an arbitrary numbe of promises
type UnwrapAll<P> = TODO;

const r01 = all([Promise.resolve(20), Promise.resolve("Hello" as const)]);
type expected1 = Promise<[number, "Hello"]>;
type T01 = Expect<Equal<typeof r01, expected1>>;

const r02 = all([
  Promise.resolve(true),
  Promise.resolve("!"),
  Promise.resolve({}),
]);
type expected2 = Promise<[boolean, string, {}]>;
type T02 = Expect<Equal<typeof r02, expected2>>;

const r03 = all([
  Promise.resolve(3),
  Promise.resolve("Hello" as const),
  Promise.resolve(true),
  Promise.resolve({ key: "value" }),
  Promise.resolve(["array"]),
]);
type expected3 = Promise<[number, "Hello", boolean, { key: string }, string[]]>;
type T03 = Expect<Equal<typeof r03, expected3>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, TODO };
#+END_SRC

- [[file:snippets/unwrapAll.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc81d6TAE7hQAMwCu8JolgN4oTNGgAecqFBUABgAUNoRAE8ADsMODMAW3CJwA+ZHl6xhvKAYi9R4doENzGcEqY8PoAfBqqoFoQJODwqPYA2lo+fpABQaEANKAAdHnJvv6BwSEJALplmeQhABSGKf6QAFyRAJQtBakBAKrwAO4CmIYAgopKWiEhANzcVACSiKDmYpCLfQwCHKB9sIgs8nKC2LuDAvqg8GLm2MJuoPWFaZDkBsagvQNDo8oToAC8oAAKgB5AAiwJm5CYslWoAEAAYAIz-eSKGpJBppHJCSAMaAAN3ANQATPDWtlOv5sVA8YSagAiAAS4EUDHpdlA0Pgq1aZVaM1ewmIxik4FQyIBlLSSgSl2uNmyTJZ0DZZWmL08QKRKIAokQRYglDqAI5iBRKQV3BGI7LC9jWcWTSFc2EI4kohTQdERKXgam4glExACMTgck+zF+nG0on0gCE9PDal9-pjNQA3gBfcN8gWau2i1DuyWRmXYBh48BBbKrAQIADm2Szarzb0B8OLoD1BqNpvNlvcbtt+vtYuJTu4LsWCIAzB60QkI48ozTAzUZ0nIpHU2ulaz2Zh7FPNyno2vg6GT9uz3T06AOOB9C16fiFKH2dmqsnr6u6Ql6YIgz6PSfJVLmGpvAWDpziWy4ynKNwCIqzL7tk5aVtWoB3g+T6gLWDagJmNbBg25QthBwjtjBXYjlIvZmsoA5wvCM7DgaYozhOFFAmCwIooQhICK2wjdvaSiAtE1hxPYF7gCEKKAsJXZ9soAAa2QAJryX8EQ1OJtStP88kScQUnxKAqmgAA-KAyItMShmmbE5n6TUhl-MZknOfYGnWbZoD2REag2bJQUBaIChpJCwobIsd7tjaWrEtkVEpbxhEzEAA][Playground]])
- [[file:solutions/unwrapAll.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXygggB4AoeeAekvgAMAFW+DATwAcE3YoBbEDEDAIBnAs2RsICHImbsEDGDh5ZhIYlFQsAfLXLx68EAA8BqYKIDa9JSrUat2gDTwAdO5vLV6zTssBdfydSbQAKNltvYQAuAwBKWM87dQBVVAB3GCg2AEEiYnptbQBuUlJqeAj+bEEAWiwAc1QcOFJWDng0zOy8kkL4AF59QxMzC3hrSPssVERBeAAJZzd3GbmhABV-fQB+CYWXd1curNz8je1tiliAsrA8YQx4GAAGAEZBgiJQya81VzgwhwEAAbiBQgAmF5xFxJbwAkBA0HggBECxARBwKJE8HuqEecX8cVK7QQJg4mBAwA+AwMU3UllQyB4ACNBC40RiIFj-CU2vJ4Bt3p8AKLGCkYYgigCOyEIxFJMme7xc5PAAmpRVKpDxj2VEM+hAgP2G9IRSLBoQwMGQIBhpr+IHNwMtKIAhCj7RQ4f9AS7wQBvAC+9qJJIFaspwANtJ9DJZOGBIE0LkeMBmDRcwd54Y6Qpj8DFEqlsvlitkrwhqvF6qpEK1dweT1eAGZDd9LA7ks7kaEW166Y6e670ZjsVBRLqMAO48PwdbbTOzX7ewH4ABrEAsWIokGEW3YkPBb3LxH+n4o2BZFgoonBMP8jqRjVt2P04iM5lsmAc0fclEuAmSYpvAa6btu8Bphm8BBqm1oZgEOaPggQqvoWNaYCWcokOWyottWEpUi2DbIYKADyAAiZGfKgIBgjAuYIEW6rEBsRimCA5iiAuIDaJ8GyMYWpYkAAGi4ACafFDBQoSsWEcSDHxbGjJx4wifAewfLEEIKSpXHwHJoQKQMSnsWMojiRp8BafAEL6BQew8fZ8CxIghBqNq5ItE8a5Cm8Lj5gFLz4eRVEwaUQA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/withIndex.ts
// eslint-disable-next-line
// @ts-nocheck

// Write a type that given a tuple will return a tuple where the elements are a
// tuple with `[value, index]` where `value` is the value from the original
// tuple an `index` is the numerical index starting from zero.

// HINT: You can read the property "length" of a tuple/array,  T["length"]

type WithIndex<_Tuple extends any[], _Output extends any[] = []> = TODO;

type R01 = WithIndex<["a"]>;
type T01 = Expect<Equal<R01, [["a", 0]]>>;

type R02 = WithIndex<["a", "b"]>;
type T02 = Expect<Equal<R02, [["a", 0], ["b", 1]]>>;

type R03 = WithIndex<["a", "b", "c"]>;
type T03 = Expect<Equal<R03, [["a", 0], ["b", 1], ["c", 2]]>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, TODO };
#+END_SRC

- [[file:snippets/withIndex.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrcysAdQCdYicKEyhEATwAOIxC0yJQAc1gA3cPFHiArlLygA7rGjRQ-cIm39NYy3pEG258Wwh4AthrqjnmHjvtDIRZQAAMAbVVMaG1wABpQBFRiAF1QwycRUKiY8HSMFxEc2NAAM34Gd0LQBkEVeGj-O31MTVCk4nzIavhtT0EmaMT4ZKJQSERMfkQEJTKKqoAvcAqAOm4qAAkASQA5ABUALlAATQZtUEHNc0xUaqkKmWmJUAAiPHglOVea0q1m8DAKb8TASBKgfbhd4aL4sV4pbiSGSgXjBbYjYgAHgA+vtdPpiMIRt1WhJwikEtiAPLaRBSWkQEgaVAk+BklKgAC8oHJAD4uRCqQARKkAbkR0hEACUAAwARgFqLk6NGmKhmHhvPFSJE+3lAoAokQZExEJiDQBHbTRTGyuUJcLq14JGUpFK8rUS5GygBMirRGKIateGoSr2wmu1kohMr93KNJrNlut0FtsYdTpdFJ54edoDlbo94vIOtAsoAzP7lYHg6G3hGw0xIyXo3rK-Hjewk1abRWMyG866HbmEgXh02Ej7C56W8j9sKqQLCOp+FHkQmu5j9oyiSzxPxYvzufs1yJkzaABoJE5H8igUAACi3vIfAEoufzt4Tmd0L6AAPz5qAxw+u+37EqAz5vh+EI7j+pwAUBIF3veiGIAe4AofexylNEkDgMWxBSLUigAN4xvaMY+gkbY0QuoAAL7ikAA][Playground]])
- [[file:solutions/withIndex.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/PTAEHUCcEsBcFNQENSwJ4AdGwBZNqAObQBu8AdsqgK4YA2iA7tHXaJPLNZJSl-UxzwOqIaHgMAthVgBnZCKQAoEDQGhmuUAAMA2iSR1q8ADSho5ACbwAHgF1tGoSO0Gj8R9Hm5Eb46AAzSAB7SVFEYJhickMVMH4GZEptC2sbT28xcmppGABjQ3MrW1BZWCRIWAtCQJCwgC9hYIA6JTjQAAkASQA5ABUALlAATWDqUALKDiRLcNAMEKxKtFAAIgZyQlxV0GCAqgT4YArIJDQzUD7ddYotnFW7NtUFzirhAFpoQnJI+CV0LAQOA4LrFGwAHj6tEStgQVnkSHIaF0djMAHlqLAMJjxDY4ZYEUiUaAALygFEAPlJSlAl2hiFhFAJ5IsAWEnTMzS5rPZfUetIA-EDcKC0pCzLouc0MVjMRKOujMdjYNcNncHnY7BSaaAhjLlQBuNoAxAAJQADABGUnCkFg8HXJAPClGk2XK02gCiNiweVg4M9AEdqIZwRbLRLHaszObNRSXcbMGbzQAmG3gYGi2wO1ZOsyrABGztdSfdabJ3t9-qDIboYdTkdz0dAsYlheblrjCf+pYtAGZ05n7VH80X83liz3AX1zQOKz74H6A8HQ-3G3mW6jye2zJ22xOzCmu0ap4g+miACJom3keBkSAlwGVxf+vq4-HeSDGKlkvqPxA1qGAAaZjDD+OoABSQhSEEAJSklSb6MvCoBAaAQrWkMKbwchzLQXBCGXO+TLyMM6GgJhoApjqgqoF+fy0rSQwBIYsjwCetgYJEBAAN7uhGZZmDOfZCZe14AL5GkAA][Playground]])

* Template Literal Types

As their name suggests, /Template Literal Types/ are the type-level equivalents
of template literals. You can use backticks (~``~) to create one, and
interpolate other types inside of it using the ~`${...}`~ syntax.

#+BEGIN_SRC typescript
type Who = "World";
type Hi = `Hello, ${Who}!`; // "Hello, World!"
#+END_SRC

** Interpolating Primitives

#+BEGIN_SRC typescript :tangle snippets/interpolatingPrimitives.ts
type SomethingAboutGabriele = `Gabriele ${string}`

// @ts-expect-error
const r01: SomethingAboutGabriele = "Gabriele"
// @ts-expect-error
const r02: SomethingAboutGabriele = "Luca is a nice fellow"

const r03: SomethingAboutGabriele = "Gabriele is a nice fellow"
const r04: SomethingAboutGabriele = "Gabriele " // ok, because an empty string is a string

export { r01, r02, r03, r04 };
#+END_SRC

- [[file:snippets/interpolatingPrimitives.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwsAFgSwHYHMCCAjOAV2AHEBDPAJzQgBtoBeKAA3KpvqgBIBvAZ2DVsAX2YAoMQHpJUAALA+AWggAPSAGNgyypTiUx6uBgFRKABgCMALliJk6bPiKkK1OoygAiNm-qepMvJKqhpaEDp6BkYm5gBMNvBIqJi4BMQ+HB6eADKE6mRQaHxQBRho6tAAZnS0cADu-lHGwKZmAMwJdsmOaS7s7lBM3q6ZhcWl5VU19f6Gza0ALJ1JDqnOGQNDG5yeUNJQcADWADRQeBD5hHzQZBhQEAhgoFACQlhjJS+CKRIhei08VoWU5xEHtMELKDCADcYiAA][Playground]])

** Destructure with Anchors

Using the ~infer~ keyword, we can pattern-match on a string literal to split it in
several parts.

#+BEGIN_SRC typescript :tangle snippets/destructureWithAchors.ts
// prettier-ignore
type Split<T extends string> =
  T extends `${infer P} ${infer S}`
  ? [P, S]
  : never;

type T01 = Split<"Gabriele Lana">[0]; // "Gabriele"
type T02 = Split<"Gabriele Lana">[1]; // "Lana"

type IpClasses<T extends string> =
  T extends `${infer O1}.${infer O2}.${infer O3}.${number}`
    ? {
        a: `${O1}`;
        b: `${O1}.${O2}`;
        c: `${O1}.${O2}.${O3}`;
      }
    : never;

type T03 = IpClasses<"127.0.0.1">;
// type T03 = {
//   a: "127";
//   b: "127.0";
//   c: "127.0.0";
// }
type T04 = IpClasses<"192.168.1.100">;
// type T03 = {
//   a: "192";
//   b: "192.168";
//   c: "192.168.1";
// }

export { T01, T02, T03, T04 };
#+END_SRC

- [[file:snippets/destructureWithAchors.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAZXABsFYAeAFVGgA9ZpMATAZ1C9kgSZ0APlABePKFCMWbTjwAGAEgDeggGbJQABQC+oVRq1ldCyaAD8oANraANOQC65gFyhM0AG7IA3HgLEpPQADACM4uRUNLQARADiAIYARgLQlKQAMgmYCTHC1sGOPqAgoPHJqekxASTSwQBMERTUdOUpSOmgWTl51qFFJWAx3bn+RLUAkuAAwpQJXFzQXAxMrOzcvPyCIuLmMmvyoMpqmJqQoADyoboAdIanWhf1t-dnlwDMLyqYAK4AtklkKZzFIrCoQVJIQk3McrqY-JDEaAkjDVHC7ionvCIYiAMaozHXDFY4mfBQIpG6CFuDzeSB+GpBYLvCJTWbzRbLGKheoAdhuwQFN1CeT8pXGTJZYlA4NKUmhZR5vJiYrAUhRir5ApVeDloHxmv5guCOtKVIldQALKyZnMFktYqEAJz1YUANgAHMLhcETcJVaALSEpTLdWrQAruS7TeGNVHXaFPTHIQb4+6vSKA1S8CxwLhYDK6qEHCF6iXmeXrbo-EA][Playground]])

** Destructuring without an Anchor

The string is split after the first character, with this we are able to compute
over a string one character at the time from left to right.

#+BEGIN_SRC typescript
type Split<T extends string> = T extends `${infer P}${infer S}` ? [P, S] : never;

type T01 = Split<"Gabriele Lana">[0]; // "G"
type T02 = Split<"Gabriele Lana">[1]; // "abriele Lana"
#+END_SRC

This means we are able to parse an arbitrary string ðŸ¤¯.

** Exercises

#+BEGIN_SRC typescript :tangle snippets/aTypeForEmailAddress.ts
// eslint-disable-next-line
// @ts-nocheck

type EmailAddress = TODO;

// @ts-expect-error missing domain
const r01: EmailAddress = "gabriele";

// @ts-expect-error still missing domain
const r02: EmailAddress = "gabriele.lana";

// @ts-expect-error missing TLD in domain
const r03: EmailAddress = "gabriele.lana@gmail";

// OK
const r04: EmailAddress = "gabriele.lana@gmail.com";

// @ts-expect-error `dev` is not a valid TLD domain (list only a few)
const r05: EmailAddress = "gabriele.lana@gmail.foo";

type TODO = never;

export { r01, r02, r03, r04, r05, TODO };
#+END_SRC

- [[file:snippets/aTypeForEmailAddress.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoAKIBbTLGgBBVKgBOUSKAC8oACoB5ACIaA3Nyq16xQUxTg5chnNCiMkBAHNQqBuITkmDeJESg5AAwAjABcIu7SsgqQSqoARI44crDgeHH6lGBGyCbs5pbWoL6S0Lb2Ti5uEvCe3r7+AQBMYWISkfKKKqAJSSl4AHTQmPCY6QZZdDlEpvlWNnYxFWoAMlqgCJXuNV4+foEAzC0RMh0xXT3Yyangg8OY1I4RY5mgGgDStbsNACxHbSfRWLdRKXPo3IYjB4RfpeUTPQyTXJmHIFGwAA1Q4AAbmj1kp4Aw-JhQFjMHBUOpVptqqAABRwereaC8UDEgBm4AA7gBKT71QIAVj+kgBnXiIKuAwh90ebX6bIYDGefEE6m0Gi6hCxFgyJmsfgA3g0ggAaBqNM0HS0Bb7WgVmzQ6UAAX30QA][Playground]])
- [[file:solutions/aTypeForEmailAddress.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAKgMgESgXigIgMYHsC2aoA+6AlsPkWhAK7noAmEAbmgNwBQokUAojgIbEANgEE6dAE4QAzlJRQABgBIA3lODjiAOwDmAXwACKtRp26AdCvgJd89mwD09qPuBSAtBAAekDMA-jxLHEoHGIZLW0oOlwBTTZsTTUocQAGAEYALh5+IVEJaVlUNG0+ACMNCEEIVjYHJxd3Lx8-CACgqDUhQRCwqQiomK14rETgZJSAJizeARExSRk5YrKKqrNBPk0+GrrnVw9vCF9-QODQ8J1YRCgtAZy4hKTUgGZpnLn8xaKS8uJKiHWmz4+m07x2jigAHkANLDUbjAAsb1meQWhXQP1WAI2WxB7zM2DwdghDQOzRO7XkDEY8husk0WDGfCgjD4gmIdCuSGi9ygAAp2UkRoIQFBmQAzCAAdwAlHCnikAKzI3LzApLTF-NY44Gg2ZmcVYLA7TjQGCQhCQuSaJitOxNIJjZTjNIAGnGE3dLy9KQRPsV7vNlqgunYQA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/toLowercase.ts
// eslint-disable-next-line
// @ts-nocheck

// Implement type utility ToLowercase as in standard library
// https://www.typescriptlang.org/docs/handbook/utility-types.html#lowercasestringtype
// only for characters in `[A-Z]`

// Can you do it without having one condition for every character?

type ToLowercase<_S extends string> = TODO;

type R01 = ToLowercase<"HELLO">;
type T01 = Expect<Equal<R01, "hello">>;

type R02 = ToLowercase<"Hello">;
type T02 = Expect<Equal<R02, "hello">>;

type R03 = ToLowercase<"">;
type T03 = Expect<Equal<R03, "">>;

type R04 = ToLowercase<"CATCH42!">;
type T04 = Expect<Equal<R04, "catch42!">>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/toLowercase.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrcysASQFsADnn7gkoRAE9B4UAFdEsOFNAAVBgBkGAd3AAnJpkiyjoBKEiJM8VJj2pQcbHruSeoFokSDIALhDagQB0UjKQTHqwgojQ1gDmQQx6ccCozJDALNao2AwMHMAKSrBSyKFQQZ780ADE0Dr6hsaWkfBx5e4M8NCSoABmSaCsdphMiPqQZvCgAAYA2gCCyABaALoz3FQAwtagkgxyoGlmiKDaJSwHp1kAbghxoF2yTF3oil39g+A3+r3DLmN9AB+bjlNSaBoGIzgAA8AH0AMoQEhiVCTFr3AB8oAAvGoAPIAEXxAG5QdJZAAlAAMAEZceCtLoocYYQAiAASAFENBp8WzMWSwao6QyuUQZGMYVyAI5yTDQGE02kAGlAbLY0HqAsF5JkoBpACYGeomY1oeyOeAtQwBUKKWpqca8eLJYhpXKFUqnWqNdbtZjdeQwTSAMwmiHMpqwtl24MOkXhl0S9ju2XyxVh306snx-U0gAsEbNLJjWwWqi2HILhoAhHHhdSi8m3R6M96C77DIhWDX64Hc8KifiGYQfnp7frXamYapkeMbJNEHo5OBsXjVJPZOmvQANNUATXX5FAoAAFLPMWeAJS47Fz4gLtGgXegIGgem+UCG2+P1GTS8bzvNR53-UADzfD9QC-Q0T1PSDl1XODTy-PoFWMXNiEEJJTgAb0dVVHUNNVExIpsSOHUAAF8ySAA][Playground]])
- [[file:solutions/toLowercase.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/PTAEEkFsAcBsFNLwHYBdSoJ7XqArqgJayFagAqA9gDKUDu8ATgMYCGAzrh6IcqO6lbIAJq0bDQJAEaMxmAFAhQAC1Spo7AFwg6ugHRYc7Zo0LRUsIQHM9lRleDDKzdsGVDhUypQDWwAsSkmAC0hvDseqqQsADEsPRMbJwCpshWYYpglMiwmKAAZnagzO6yzKhM7Dx8AAYA2gCCwQBaALo18pmgAMJCoJiUeKBOPOh0pMqD6O4AbrxWoNm4zNnCpITZBUXwM0x5JWKs5UwA-J1hFDQJLBzwALKs0KAAvKAA3vKgoA2aoABErD+AG5PqAAEK-P5SYGg7qQ5gwr4AEUhwkRoAAopD4OiAGKQ-LogDikKs6IAEpDlOjwJDCOiAFKQgBW6IA0pCfOjqJDYOi7pDIOiAHKQ5DogDykMo6IACpDoOiAIqQgCO6IASpDGOiAMqQ9jo8iQ1DogCqkLw6IAapCZuiAOqQujogAakIAHuiAJqQzDo5qQgBeMIAviCutBGPA1IQmMFCFZkHZ4PILlRaAwbpwADy60DwD0VERVFLzAB8L1B+cLxeEVRqABI3rx8kxQOTQ83W+3yKGOl8TqAm29yQWiyh66AfPABvlLpnErcHk8hxnrkl7o86uTWr9O8311nNznyOX+6DIX9zthcBqAAwARheC43txzf3JGOo1Alf3LILpk+L4Yh6ODlDmGKqngrCwDmD6PgANP8yjwLA8T-gBN44KAD4AEwvkeS65p+aEYVhQEEa8oHgagkHQbB8H3nhyF-Kh6EyuWWFpreuH3gAzIRVzHu+fz-oBvHkAJIFgfAEFQTBcEPvxrGYRGFwPgALEJi7ZvAH7dA05DdOSml4QAhOJPE4VJ2nUbJ8kMUp96aaxbCoCUZmWVx6mSRKSISi+yA7EwEk4TRcl0eQ451lUqCMHg8CVq85BhbgCmMa6yHesloIABSnuWeUAJQvJW0W1pOVSuqAQ7Pr8eGlZVJagIVJVlRQMVVaA3q1aA9WgHhoKDhgCWpl8Xy-PksGcBGhbQHY6BvBQT7IVJLErSpK2uRQ-mBeG8hAA][Playground]])

TODO: smartGet exercise

* Mapped Types

Mapped Types is about transforming objects.

TODO

* Slide 1
This is an example of a slide

#+BEGIN_SRC typescript :tangle snippets/example.ts
export const z = "foo";
#+END_SRC

- [[file:snippets/example.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBAXjAvDARAMxCFBuAUEA][Playground]])
- [[file:solutions/example.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBAnjAvDARAMxCFBuAUEA][Playground]])

* Slide 2
Content

* Slide 3
Content
