* Introduction

What I mean by "Type Aided Programming"?

- *Rule 1*, keep the definition of the types as close as possible to the set of
  values that you know are good.

  #+BEGIN_SRC typescript
  // Bad ðŸš¨
  type Action = { name: string;
                  key: string;
                  value?: string;
                }
  #+END_SRC

  #+BEGIN_SRC typescript
  // Good âœ…
  type Action =
    | { name: "GET";
        key: string
      }
    | { name: "PUT";
        key: string;
        value: string
      }
    | { name: "DEL";
        key: string
      };
  #+END_SRC

- *Rule 2*, be as strict as possibile with the outside world because it's dark and
  full of terrors.

  What I mean is that you should:
  - Validate incoming requests.
  - Validate incoming messages (Ex. queues).
  - Validate external configuration.
  - Validate database data (... let's talk about it).

- *Rule 3*, do not cheat (altough sometimes TypeScript may need a little help).

  Scenario: you have JSON schema for an incoming request and a library able to
  validate at runtime the request given the schema, since this is done at
  run-time you have no type-level knowledge of the types. What you can do is to
  derive the type of the payload of the request from the schema and cast it
  after the validation.

  #+BEGIN_SRC typescript
  type Payload = FromSchema<typeof payloadSchema>;

  const validationResult = validate(payload);

  if (validationResult.isOk) {
    // If the run-time validation is ok then we can safely assume
    // that the type of payload is the type derived from the schema.
    // Spoiler: see the last challenge of the workshop.
    const payload = validationResult.data as unknown as Payload;
  }
  #+END_SRC

* More Formally

It's achieved by representing truths or constraints in the language type system
so that when they become false the compilation fails.

#+BEGIN_SRC typescript :tangle snippets/companies.ts
const companies = ["Google", "Facebook", "Apple"] as const;

type Companies = (typeof companies)[number];

type CompanyConfiguration = { rating: number };

type Configuration = {
  [K in Companies]: CompanyConfiguration;
};

const configuration: Configuration = {
  Google: { rating: 3 },
  Facebook: { rating: 1 },
  Apple: { rating: 2 },
};

export { configuration };
#+END_SRC

- [[file:snippets/companies.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBKC2AHAhmAlgUwjAvDA2gEQDiIIA5gDYaEA0MhAYssBgEZkDWdDAgoomqEAujGTZQkKAG4AULKgBPRBhgBhEElSZseABRKVIAGZxNKdFgCU+MAFd4bDACdhchctUatYRRrDGaOR2zshQaOC4MADeMKHhYOQAXDD2ji4wAL7uhl7ggcHxEWBR0bIwBADSMGgl3hY6win1qH75QSFhxXLZ8pLQZgEdReDN7YVdkXhlFaQU1CmxRYkpAMxZtOUwzKwcIJyLcV0rMACMG1v8ghiHy8kwAEwXvbIYAB6IIM6wsZIFneFIr0gA][Playground]])

* Why TypeScript?

Why TypeScript? TypeScript type system is (incidentally) more advanced than what
you (probably) think. TypeScript's type system is a full-fledged turing complete
programming language, limited, but powerful.

We will refer to the subset of TypeScript that deals with types and guides the
type checker as the "Type-Level TypeScript" programming language.

Every programming language is about transforming data, /Type-Level TypeScript/
is not exception, but its purpose is to *transform types*.

NOTE: This approach is orthogonal to /Object-Oriented Programming/ and
/Functional Programming/ it can be applied with both.

* Types

You can view types as sets, aka a type is isomorphic to the set of values of
that type.

#+BEGIN_SRC typescript
type Primitives =
  | number
  | string
  | boolean
  | symbol
  | bigint
  | undefined
  | null;

type Literals =
  | 20
  | "Hello"
  | true
  | 10000n

type DataStructures =
  | { key1: boolean; key2: number } // objects
  | { [key: string]: number } // records
  | [boolean, number] // tuples
  | number[]; // arrays
#+END_SRC

* Composing Types

There are two ways of composing types. They are not operators, they are
constructors, they act on types but they don't manipulate them, they put them in
a box, we can still access those types and manipulate them later.

** Union Types

You can read as: a value of type ~TurnAction~ can have either a value of type
~"left"~ or a value of type ~"right"~

If you look at types as sests, the type constructor ~|~ is the equivalent of
union for sets.

#+BEGIN_SRC typescript
type TurnAction = "left" | "right";
#+END_SRC

** Intersection Types

You can read as: a value of type ~Employee~ has a field ~"id"~ of type ~string~,
a field ~reportTo~ of either type ~Employee~ or ~null~ and it must be also a
value of type ~Person~.

If you look at types as sests, the type constructor ~&~ is the equivalent of
intersection for sets.

#+BEGIN_SRC typescript
type Person = {firstName: string, lastName: string};

type Employee = {id: string, reportTo: Employee | null} & Person;
#+END_SRC

** Exercises

- What's the type of ~string & "foo"~?
- What's the type of ~true | false~?

* Special Types: Never

Type ~never~ is the subtype of every type, it's also called /bottom/ (symbol: âŠ¥)
because if you visualize the type hierarchies with supertypes at the top are at
the it occupies the bottom.

If you look at types as sests, the type ~never~ is the empty set.

A ~never~ value can be assigned to every type, but you cannot produce a value of
type ~never~, and for that it will be very useful.

#+BEGIN_SRC typescript
type X = never | string; // string
type Y = never & string; // never
#+END_SRC

It can always be placed on the right side of an assignment and never on the
left (TODO: see assignability).

#+BEGIN_SRC typescript :tangle snippets/never.ts
// @ts-expect-error only never can be assigned to never
const x: never = null;

// never can be assigned to eveyrhing
// ...but you have to cheat to create a value of type never
const y: string = undefined as never;

export { x, y };
#+END_SRC

- [[file:snippets/never.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAEBcGcFoFMAeAHeBjSCBOWD2XRcA7AGwE9Qj4A3eAtAQyNACN5QHpoBLAcyoAmoSLko06AKDTFokUIgBcY2gQC8lAK4kSAbgkSQyuqEbM2HLn0HDR4slgAW3IrwNgAdJ5Ya5ZXBtAHBlobEwd4BjkREywIyHYGUGoGEg12XAAzYTJUIywpGV8lWSxnXlB1DSIBeAzneCFOPL0JJGR8OQBveQAaUAoAXwkgA][Playground]])

** Ensure Code is Unreacheable

#+BEGIN_SRC typescript :tangle snippets/unreacheable.ts
const companies = ["Google", "Facebook", "Apple"] as const;

type Companies = (typeof companies)[number];

function unreacheable(_: never): void {
  throw new Error("unreacheable");
}

declare const x: Companies;

switch (x) {
  case "Google":
    // do something
    break;
  case "Apple":
    // do something
    break;
  case "Facebook":
    // do something
    break;
  default:
    unreacheable(x);
}

switch (x) {
  case "Google":
    // do something
    break;
  case "Apple":
    // do something
    break;
  default:
    // @ts-expect-error Argument of type `"Facebook"` is not assignable to type `never`
    unreacheable(x);
}
#+END_SRC

- [[file:snippets/unreacheable.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBKC2AHAhmAlgUwjAvDA2gEQDiIIA5gDYaEA0MhAYssBgEZkDWdDAgoomqEAujGTZQkKAG4AULKgBPRBhgBhEElSZseABRKVIAGZxNKdFgCU+MAFd4bDACdhc2cbthgUNOBhezhgsABbBbNR6APoAXDBgGABuLlZxiSBoACYwAN6yMDBQIc4gAO7xGOUAos4lznqEgcHAYcgRNFZyAL7ymRjAlMhBZlIwAB5xGlqWEO4QpWhQLTB6Y1a5+XDiqiRkVDQxmwUA9McwmSAwEJoYRWhg5EcwbEHInHIFwNt8AkKHBSczhcrjc7g8ni9gu9Nl8IDtmKwOCBuP8AadzpdrvBbiF7o8Ac9XtCCn1jMg7JQoKiCk1QuFImtuvJ5otlqt1nlPt9dhQ-k90cCsTi8RCiR8tnCfoIDvygZjQbjwQTIW9xaTyZTqTB0QABKAQAC0GDGKh8RtqIGcMF4znIDgwYFgJkKylUAAMmCx2FxCG6YGhsGAQLBxBA0OQwG1qIVLoZ3Qlks43U9aS16Rh2UygA][Playground]])

* Special Types: Unknown

Type ~unknown~ is the supertype of every type, it's also called /top/ (symbol:
âŠ¤) because if you visualize the type hierarchies with supertypes are at the top
the it occupies the top.

If you look at types as sests, the type ~unknown~ is the superset of every set.

#+BEGIN_SRC typescript
type X = unknown & number; // number
type Y = unknown | number; // unknown
#+END_SRC

A value of every type can be assigned to ~unknown~, an ~unknown~ value cannot be
assigned to anything.

#+BEGIN_SRC typescript :tangle snippets/unknown.ts
declare const x: unknown;

// @ts-expect-error `unknown` cannot be assigned to type `string` (downcast)
const y: string = x;

const z: unknown = "anything";
#+END_SRC

- [[file:snippets/unknown.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/CYUwxgNghgTiAEYD2A7AzgF3gDwFzwFcUBrFJAdxQG4AoGgenvgAEM0BaEbAB3A05gwkMeAAMipCilGIoKMlgBGCKGjQBLAOYoQweBiT6AnrzGYY6lJpkAKYFLCqMAShrJ0WI-nOXN8ALw4tG6omPAAXvgSZJQB8ABEckYYABa+8bRAA][Playground]])

So everything can become ~unknown~ (upcasting) but you cannot do anything with a
value of type ~unknown~.

* Special Types

- Type ~any~ is another top (âŠ¤) like ~unknown~, but you can do everything with
  it. To be more precise is the sum type of every type but not quite. Very
  dangerous, do not use it, use ~unknown~ (always have ~strict: true~ in your
  ~tsconfig.json~ configuration)

- Type ~undefined~ has a value ~undefined~, ~undefined~ is a subtype of every
  type, meaning ~undefined~ is another kind of bottom, but this time (as opposed
  to ~never~) it has a value which is ~undefined~. You can avoid this with
  ~strictNullChecks: true~ in ~tsconfig.json~ (included in ~strict: true~), with
  this flag the only value of type ~undefined~ is ~undefined~ itself.

- A declared variable has value ~undefined~ before its first assignment.

- Type ~void~ represents the absence of value, ~undefined~ is a value of type
  void.

- Type ~null~ has a value ~null~, ~null~ is a subtype of every
  type, meaning ~null~ is another kind of bottom, but this time (as opposed
  to ~never~) it has a value which is ~null~. You can avoid this with
  ~strictNullChecks: true~ in ~tsconfig.json~ (included in ~strict: true~), with
  this flag the only value of type ~null~ is ~null~ itself.

- A ~null~ value is an object (due to an error in the original JavaScript
  implementation ðŸ¤®)

- TLDR:
  - Always have ~strict: true~ in your ~tsconfig.json~ file.
  - Always use ~unknown~ instead of ~any~.
  - Always use ~undefined~ instead of ~null~.

* Generics

A generic type, is a "parametric polymorphic" type.

#+BEGIN_QUOTE
In programming languages and type theory, parametric polymorphism allows a
single piece of code to be given a "generic" type, using variables in place of
actual types, and then instantiated with particular types as needed.
#+END_QUOTE

We call variables that stands for a type "Type Variables".

We call a type without type variables a "Complete Type" o "Concrete Type".

We can introduce type variables in different places:

- Interfaces
  #+BEGIN_SRC typescript
  interface Container<T> {
      content: T;
  }
  #+END_SRC

- Classes
  #+BEGIN_SRC typescript
  class Container<T> {
      constructor (private readonly content: T) {};
  }
  #+END_SRC

- Functions
  #+BEGIN_SRC typescript
  const container = <T,>(content: T) => ({content});
  #+END_SRC

- Type definitions
  #+BEGIN_SRC typescript
  type Container<T> = {content: T}
  #+END_SRC

** Type Constraints

On a /Type Parameter/ we can specify constraints (/Constrained Parametric
Polymorphism/)

Useful feature because by enforcing constraints on a /Type Parameter/ we can
tell TypeScript what you can do with a value of that type. Moreover since
TypeScript is structurally typed the constaints are quite flexible.

#+BEGIN_SRC typescript
class Greetings<Named extends {name: string}> {
  constructor(private readonly subject: Named) {}

  render(): string {
    return `Hello ${this.subject.name}`;
  }
}
#+END_SRC

** Use of Never as Type Parameter

#+BEGIN_SRC typescript
type Result<T, E> = {_tag: "ok", value: T} | {_tag: "error", value: E}

type Flawless<T> = Result<T, never>;
#+END_SRC

** Exercise pickOne

#+BEGIN_SRC typescript :tangle snippets/pickOne.ts
// eslint-disable-next-line
// @ts-nocheck

function pickOne(a: TODO, b: TODO): TODO {
  return Math.random() > 0.5 ? a : b;
}

const res1 = pickOne(true, false);
type test1 = Expect<Equal<typeof res1, boolean>>;

const res2 = pickOne(1, 2);
type test2 = Expect<Equal<typeof res2, 1 | 2>>;

const res3 = pickOne(2, "some string");
type test3 = Expect<Equal<typeof res3, 2 | "some string">>;

const res4 = pickOne(true, 7);
type test4 = Expect<Equal<typeof res4, true | 7>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { test1, test2, test3, test4, TODO };
#+END_SRC

- [[file:snippets/pickOne.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8gMwFd4TRLAbxQAB1icA8oQAUmAFygAKtIAi0gDShsytZoCU+jdNABvcqFAAncIj42xAWUyIWAOhuZ4qBgFs5Q1AAPlAABg8AVlAAflBMUGVsAG5yAF9uJlFIRFsoAEZQAF4JKQ5ZcDlEGz5wHR5MaEhwQzTEAE9xcFBEKEQi0oBRIm6hAB4hgEc+JvHO7oYefMgCnWwGBjwfEJC08mz4XJWAJhKymXk10BO28gWevtyz4dH2REmZuYel050igA+N12+0OxzskAAzOdJJcqicdAAiSABHq5GwIADmiLuD16-WhrzGH2ms2g8y64F+EMhOjOQORqNA6KxiJBWRyeQhABYYeVKtVavVQAB2XGU-G5XlE96fMkUxbLHk6Gp1UBAkXs+4SgxmUqEABu4Bs7QlI2J4xUEBI4F8kF6QrCpRUpu6oFJcwAGjoAJpOqygOSWkJBEphK3EPp20CeuKgIrKW7WqOoe3B0PFcPJ22p0A+uMJm4B6zxVXgYtJUCNZrgfbEcQMGx5cySgYq-oI1u01vcnS60DpNJAA][Playground]])
- [[file:solutions/pickOne.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/GYVwdgxgLglg9mABABxhA1geTAUwDwAaANIgJoB8AFAIYBcixiARvaQJT0GIA+ZiA3gChEiAE44oIUUgCy1KAAsAdKOpgAJnAC2lNonKIADEoCsiAPyJqiekwDcggL6DBEBAGcoYnO4CMiAF4UNCxcSihREBwSYGoAG3ccNgcoAE9kHEQoHyh-IIBRAA8M6Dx8gEcQeLw0jLhgbz8SJjg4OJw1cnIHVw8vcXcAJkDgjGwcSl8SQeTBWszsz2GC4pxSiqq4mvScesbBkn9eQa6etzBPRoBmEdQxsIPEACJ3bUzPURgwAHMn2fmsjkbisSlAypVqvM9gMrtMeM9Xlp3hEvr9Ti5zpcBgAWW4hcbhSLRRAAdn+O0BnlxILWYI2kJ20J82JIESi8JJ6LmFIAKpgACKYEa4ABuOFEKQpRVBeB5iBwhWyGncWSJBiCPMlGUQ9K2jAogWEiEosqoegCBjlCqV6hVXEs-noM3lipwysQpt0gUtLptKtIFkQjsQgyNIksbJwYZsiFiCRwPQVyDgoi8-EpuVZOUeiygsIzLMQfMFiEcDiAA][Playground]])

** Exercise mergeTwo

#+BEGIN_SRC typescript :tangle snippets/mergeTwo.ts
// eslint-disable-next-line
// @ts-nocheck

function mergeTwo(a: TODO, b: TODO): TODO {
  return { ...a, ...b };
}

const res1 = mergeTwo({ name: "Bob" }, { age: 42 });
type test1 = Expect<Equal<typeof res1, { name: string } & { age: number }>>;

const res2 = mergeTwo({ greeting: "Hello" }, {});
type test2 = Expect<Equal<typeof res2, { greeting: string }>>;

const res3 = mergeTwo({}, { greeting: "Hello" });
type test3 = Expect<Equal<typeof res3, { greeting: string }>>;

const res4 = mergeTwo({ a: 1, b: 2 }, { c: 3, d: 4 });
type test4 = Expect<
  Equal<typeof res4, { a: number; b: number } & { c: number; d: number }>
>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { test1, test2, test3, test4, TODO };
#+END_SRC

- [[file:snippets/mergeTwo.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8gMwFd4TRLAbxQAW3AAnAObgAKgHcGACkwAuUPIDyAEW0AaUNk079ASlN7toAN7lQoKeER8pY26AB0PzEZ9e2KAAvgDc5MHcTKKQiE5QAIygALwS0nJKqp7wmJKaAEQAQgzY+SFGnphymgAsAEwh5uGIAJ4ADuCgiFCISakAokQdQgA8-QCOfJjQI60dDDzxkAkVoDl5oLFSCDIhoABkdqBV4JrwfOLY0iEAfDfh5NHwsUsNqZKyCsoqnjLOLjsCgAJcDQaAMMrBCrBJrkOadbqxN6gQbDRBjSbTWbtcALV6rP7gAHwGSaLY7W73KIxOLOSAAZhSaU+mR+UKOhOJpNA+RBYIhjWaOK6PUZAyG7HREymM3heLp9IJ-2EJLJiG2JMpDyeLzpNSZHwy30qmhWxk0DXZniYmkVoFQtUFcOFiMQ+vFaJGDhRmNlOPlUBqqw0awuVykoXNocu12CByONuj4cjDqTsZu5Cpzo6WmsTMIADdpEKc6jJSN5BASOB4KhIF0pHxwDcmfIS51pViABpGACaLeS3pUFZuKnMKRbleI3Vr9a7oAA-KAkhbx9Oa3XQCOxxOtFWZ5ve4vl6ALd7HEv1U3z6fQDxppBwA9iG0GFI4p5XWbXXUjK67a6Qa5voIThEAA][Playground]])
- [[file:solutions/mergeTwo.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/GYVwdgxgLglg9mABAWwKYCcDmqAqB3OAHgA0AaRATQD4AKAQwC5EzEAjJigSieMQDJKiAN4AoRInSooIdEiGIAdErrklC1ogC+AbhGaRIiAgDOUCamMBGRAF4UGbPjg15YOmiYAiAEJxWnrXJ5OmwmABYAJi1OXSgATwAHVEQoCyhrOwBRAA8k6EJMgEcQOgAbQnikuGBzKyDENw9EU3QYMEwtfmFEENQmMBBkVgwtKipdQxMzSWMouzQsXAIXRExJKTbMLwAJVFLSuADNIM0YkUrk1NM5xBy8qALisorE1GraiPq11A32phbNqNxgYjGBTLUAMy2eyLJwuY7db6-LaITy7faHaKxV4pNJQrK5VD5IolcoXd4zCFfdawP7NKCtdpAiag8EzMLQhaOZbBJiWcjsRBRBHyCBMKmIAAm4Sx5xxVygHIJ90IYluTzJrwpFjC9UYDUGw3Q2jY-UNI00XVFZqGGBN0oNtvQoxEwLlSUQOAA8gARL3QsCoABudvdyTuRIeOEQqGyqTAkuMKXQIFQVGhOGxHpJzxY1FsapohBwtE4tnT0dj8cTzEQAH5ENYmBEy1XUAmk8XS+XPTG4+2axR643EM21eIGwzU+PR4hgGVjKgJrGEnB0GZ5Ar+bjruQFRKFbrPb7-ToREA][Playground]])

* Structural Typing, Subtyping & Assignability

A programming language is /Structurally Typed/ when type compatibility and
equivalence are determined by the type's actual structure or definition and not
by other characteristics such as its name or place of declaration.

When ~X~ can be used in place of ~Y~ then ~X~ is a subtype of ~Y~ therefore ~X~
is assignable to Y (see "substitution principle").

When ~X~ is a subtype of ~Y~ therefore ~X~ is assignable to ~Y~.

#+BEGIN_SRC typescript
declare const x: SUBTYPE;

const y: SUPERTYPE = x;
#+END_SRC

You can also say that /Upcasting/ is always safe, /Downcasting/ must be proved.

In a structurally typed programming language types can be structurally inferred
and not declared.

#+BEGIN_SRC typescript :tangle snippets/turns.ts
type Turns = "left" | "right";
type Directions = "up" | "down" | "left" | "right";

// Directions is a subtype of Turns
const t: Turns = "left";
const d: Directions = t;
#+END_SRC

Structural typing is more flexible than nominal typing.

Dig deeper [[https://github.com/microsoft/TypeScript-New-Handbook/blob/master/reference/Assignability.md][here]] and [[https://www.typescriptlang.org/docs/handbook/type-compatibility.html][here]].

** Branded Types

Structural typing sometimes is not what you want.

#+BEGIN_SRC typescript :tangle snippets/structuralClasses.ts
class Foo {
  constructor(public readonly id: string) {}
}

class Bar {
  constructor(public readonly id: string) {}
}

// Probably not what you want
const x: Bar = new Foo("123");

export { x };
#+END_SRC

- [[file:snippets/structuralClasses.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYGwhgzhAEBiD29oG8BQ1rHgOwgFwCcBXYPeAgCgAciAjEAS2GgIFMwATHEAT2gY4AuaPgINsAcwCUKAL6p5qUJBgAhMARTpMOUSTKUa9Ji3ZdsvfkJGFx0uQtSoA9M+gAFAvFph6fbPB40ADuABZgQTzwRCFg2HhKukEAHsLqmgC80NiswXCIFABEAIwATADMhVIA3E6syVTkQcjQydCytUA][Playground]])

Brands to the rescue

#+BEGIN_SRC typescript :tangle snippets/brandedClasses.ts
class Foo {
  private readonly __brand = "Foo";
  constructor(public readonly id: string) {}
}

class Bar {
  private readonly __brand = "Bar";
  constructor(public readonly id: string) {}
}

// @ts-expect-error type Foo is not assignable to type Bar
const x: Bar = new Foo("123");

export { x };
#+END_SRC

We can also brand primitives to improve type safety

#+BEGIN_SRC typescript :tangle snippets/brandedPrimitives.ts
const __brand = Symbol("__brand");

type Brand<B> = { readonly [__brand]: B };

type Branded<T, B> = T & Brand<B>;

const makeBrand =
  <const B>(_b: B) =>
  <T>(t: T): Branded<T, B> =>
    t as unknown as Branded<T, B>;

type UserID = Branded<string, "UserID">;
const makeUserID = makeBrand("UserID");
type User = { id: UserID };

const user: User = { id: makeUserID("123") };

type CompanyID = Branded<string, "CompanyID">;
const makeCompanyID = makeBrand("CompanyID");
type Company = { id: CompanyID };

const company: Company = { id: makeCompanyID("123") };

function joinCompany(_user: UserID, _company: CompanyID): void {
  // irrelevant
}

joinCompany(user.id, company.id);

// @ts-expect-error Argument of type 'CompanyID' is not assignable to parameter of type 'UserID'
joinCompany(company.id, user.id);

console.log(user);
// {
//   "id": "123"
// }

console.log(company);
// {
//   "id": "123"
// }
#+END_SRC

- [[file:snippets/brandedPrimitives.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBA+nARgJwIZgCYwLwwMoCeAtoiADYAUARAiuhlQJQDcAUK1AQA4CmMAQmkwAefgD4cMAN4xkPVBnBkCMANq0hGALoAuATAC+bDtz6D6PDMIAqAGgETc1mADIBm0WOOhIsIqgBrHnNMHFYYGGEfaAcKJD1+RhwxcMjrMQooPWtGBM1LG3txZNSI2FQIGABXMACwEAB3MBgK9wsrOwdjTl4YAFUIHmQASQARSRCMAuhkAEswAHN7KgGhsaovVmi-QJ5VkfHcfyDJ6n31lhNe-ckZWYw9c-Gjdm3qweRHj9uYe71jvYfMbUACMACYAMxMQzdUwwADCICIXHQBDGE3yVhm8yWMCoiORqPWmzeAIJKLAaMOMABp3xSIpVKYbB6fHJqJ+fwRDKJz284BioEJlL07MpnIeNN2YqpoMh0JerAAZjVgFBZuAYAArEDzGVxKofL5rUb2OBCxminmUsa5GAAN11WCkqQA9K7fsg5GQePb0FBWAZ2Dq9daCBRDUMAHT3ewW1ExjCXVjumAAASgEAAtDwAB68NU5r0gZAwACCyAWVSIPDAsBASpgrJgAHIZWMW79KvVyhAILMFmBUIgfU2QDAUWga1AhjAG024S2ni3WCGwPr45TE-ZI8hE8nouQeFGyCAFhGPpdUy7UxEqPcqHoqOCoSmPUGtgKjyezxRNwQrw9G8PTvB8nxfKg30MVggA][Playground]])

* Conditional Types

In /Type-level TypeScript/, code branching is known as /Conditional Types/. The
syntax is very similar to the /Ternary Operator/ we use in JavaScript

#+BEGIN_SRC typescript
X extends true ? true : false;
#+END_SRC

Before the question mark stands a condition. It's always of the form ~A extends
B~, which is how you ask "Is A assignable to B?" to the type checker.

Conditional types only start to make sense when branching on type parameters, so
let's implement our first very simple /Type Constructor/, meaning a type with
type parameters.

NOTE: you can find places where ~IsTrue~ is called a Type-Level Function, I
don't like it, I think it's misleading.

#+BEGIN_SRC typescript :tangle snippets/isTrue.ts
type IsTrue<X> = X extends true ? true : false;

type X = IsTrue<true>; // true
type Y = IsTrue<false>; // false
type Z = IsTrue<number>; // false
type W = IsTrue<never>; // never, why?

export { X, Y, Z, W };
#+END_SRC

- [[file:snippets/isTrue.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAkgzgFQE4FcIB4AaA+KBeKTKCAD2AgDsATOKYVaAfjoagC4oAzAQwBs4IAbgBQw0JEL5YiBunppsgqAHplLNGPDQAmlPjI06HvwiKVa4wM0SAWnpmGKKALYAjCEjOqufK+OgA6vYGGBQQAG4eXmphkUgANFAA7gAWIIyipGAA9kjAUADehInaiTaJQQC+IkA][Playground]])

We check if ~X~ is assignable to the literal ~true~, return ~true~ if it is, and
~false~ if it isn't. With a literal type on the right-hand side, extends
essentially behaves like a type-level ~===~ (Exercise: why?).

Let's try to implement an ~If~ at type-level

#+BEGIN_SRC typescript :tangle snippets/if.ts
type If<C, X, Y> = C extends true ? X : Y;

type X = If<true, number, string>; // number
type Y = If<false, number, string>; // string
type Z = If<boolean, number, string>; // string | number

// Exercise: change the `If` defintion so that the following line will give a
// type error because we want to accept only booleans as first type parameter.
type W = If<[], number, string>; // string

export { X, Y, Z, W };
#+END_SRC

- [[file:snippets/if.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAkgZgHgMIBooA00E0B8UC8USUEAHsBAHYAmAzlMAE4Cu0A-BlAFxRYDcAKAGhInQvARNWaSswC2AIwiM0tJgEtKAcxx8oAen1RZi5cPDQsBWIjgBDADa0IM+UpVQ1jTTr2HPGtrmogBa1hIKAPaRDhB2lK6mHl4+ugZGKdpQAD7GbmYC-gCipMoAxurOPGUAFvFa0MA10AAG8C1Q1BBwmsDqkZSekQx1wCPQcDEOkQDuPlAOmtBzDg5QWuoAbtB2hUYi0MqMkYxQSmV2zM5QM8vxY8DDdmVlEGBjAw4gZ9Gx8fR2eg9RhqBgWKBgOyMOxyCAURgAOmC0AA6uFEABtAC6iXcqkCvnSAW8QQEZDAJzGAG8MNg0CE0GiAL6CIA][Playground]])

** Nesting

Conditional types can arbitrary nested.

Convert ~Direction~ to a number.

#+BEGIN_SRC typescript :tangle snippets/indexOfDirection.ts
type Direction = "left" | "right" | "up" | "down";

// prettier-ignore
type IndexOf<T extends Direction> =
  T extends "left"
  ? 0
  : T extends "right"
    ? 1
    : T extends "up"
      ? 2
      : T extends "down"
        ? 3
        : never;

type _ = [
  Expect<Equal<IndexOf<"left">, 0>>,
  Expect<Equal<IndexOf<"right">, 1>>,
  Expect<Equal<IndexOf<"up">, 2>>,
  Expect<Equal<IndexOf<"down">, 3>>,
];

type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { _ };
#+END_SRC

- [[file:snippets/indexOfDirection.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAIglgJwgY2HA9gOygXigIgBsIAzYfKAHwITgHMALcqggVzAuvwBN0B3TPgDcAKBEB6cVDBJgaCAgC09TOiQjQkKAElM3CAA8A8iQA8AFSiHgEPQGdYiFGiwA+XCKhRL129wdEpOSeUAD8UAAMIQBc3lYGNvY09Ez4IV7hAIzpULE+CX4B7GlepWFQAEw5Xnnxif4EvAIlZaXhAMzVpbGYEABuCqIa4NAA+rhQANohAKIGkKimMwCOrACGhKa6+sZmgWT4rgA0ka7Hs-POS6sbW3qGJqb4tIzkx1CZZ0cXC8DX65ttg89sV3hUvj8risAXcdo8ePxBO92hCALpDTTQOa-Cx1QpQYAIVgQdx4cyiTFQaG3AAaJwAmqSQgAKCyuZkASlw7ny9QcNPKmVylS5viSbM53LiYoa9MFwqqZXChOJOViJA2dggQ0MYDUwCgAG8oOMAL6iIA][Playground]])

** The Power of Infer

The ~infer~ keyword is the real superpower of /Conditional Types/. It enables us
to create a type variable by destructuring the type on the left-hand side of
~extends~

#+BEGIN_SRC typescript :tangle snippets/inferRole.ts
// prettier-ignore
type GetRole<T extends { role: unknown }> =
  T extends { role: infer X }
  ? X
  : never;

type T01 = GetRole<{ name: string; role: string }>; // string
type T02 = GetRole<{ name: string; role: "admin" }>; // "admin"
type T03 = GetRole<{ role: "staff" | "service" }>; // "staff" | "service"

type T04 = GetRole<{
  role: { name: "admin"; permissions: ["read" | "write"] };
}>; // {name: "admin", permissions: ["read" | "write"]

// @ts-expect-error wrong type, missing `"role"` field
type T05 = GetRole<{ name: string }>;

export { T01, T02, T03, T04, T05 };
#+END_SRC

- [[file:snippets/inferRole.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYChYBPcaUAcTgCVsAbaAHgBVRoAPWaTAEwGdQBvUJFrQAXKACumANY4A7plABfAHygAvHlChmbDtz6DhdcQkwAzZKAAayraAD8N++MzQAbsgDceAsVKMAAwAjBrkVCL0gpgAhgC2YqA8sJBm6F5CIuLJqZjoyioZIEkpaX4kOoEATGEUsNR0UaCxCdmleRnGiQBEMVxxZt0FRWC9-YPlAYEAzLURjUZZoN3JMebmQwA+yzzI7ggAxtBDqiM7sGsboNsre4fHvkQVQQAsc-WR-PZd4tHxPX0BphuhkSJABjweAhsJgeOIANrdGB9LbLOSpDjdAC6yh8p1AxX4LQB42BABoIMgIVCYXDQIjkVxUd10QhMVjfMUAAKwHgoNgkA6wfmQYSQUDomH5J7QCnUtKgAAGSJE3UVoHMSBoXEmlQArO8Ggw-q0Srl8qdfALcLABJVghSglVHTMXS8XQalD4gA][Playground]])

We can destructure every structure known ad Type-Level, see later for more
examples on Arrays/Tuples and Strings.

#+BEGIN_SRC typescript :tangle snippets/returnType.ts
type ReturnType<F> = F extends (...params: any[]) => infer R ? R : never;

type Fn = (name: string, id: number) => boolean;

type T01 = ReturnType<Fn>; // => boolean

export { T01 };
#+END_SRC

- [[file:snippets/returnType.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAShwFcBOA7AKuCAeAYgPigF4ocoIAPYCFAEwGcoAKAOlbAEMl2BbOgLijsUIANoBdAJRECASxQAzCElhQA-CoEoIANyUBuAFAHQkEiiJMUPCALrAkcgOYAaKDJqaE3AEZKphAm8AeyCAGwghQ2NMKDQABgBGCzhEVAxIXBQ8PSgAelzpKGCwiJQjCjAgpGAoAG9YxKgAX0MgA][Playground]])

Even custom generics.

#+BEGIN_SRC typescript :tangle snippets/destructureGenerics.ts
type Container<T> = { content: T };

type Contained<T extends Container<any>> =
  T extends Container<infer X> ? X : never;

type T01 = Contained<Container<string>>; // string
type T02 = Contained<Container<[boolean, number]>>; // [boolean, number]

export { T01, T02 };
#+END_SRC

- [[file:snippets/destructureGenerics.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAwg9gO2AQwJYIgJwDwBUB8UAvFAN5QDGiwESAXFLlAL4DcAUO6JLNWhgBM8UCAA8aCAQGdeSflmzIEIfISLsojEeNrTZKdAvQAzLFAAahAPwWoDDADcsHLuGi4ADAEZi++UPg5QxwpYEx0AHNVVigAelioUPCECNceTwAmX0CDQWwc+RwAbQAjODgAGwglABooBABXAFsSrABdaLiE0vKq2vrm1sw2zjEwOExgMkZvOsyWDiA][Playground]])

There is no standard syntax for declaring block-scoped variables at the type
level. This is a shame because we know how much more readable the code can be by
declaring intermediary variables with sensible names. It can also help
performance, we can store the result of an expensive computation to reuse it
multiple times later without having to recompute it every time.

But we can use ~infer~ for that.

#+BEGIN_SRC typescript
// Good âœ…
type TwoTimes<X> = ExpensiveComputation<X> extends infer R ? [R, R];

// Bad ðŸš¨
type TwoTimes<X> = [ExpensiveComputation<X>, ExpensiveComputation<X>];
#+END_SRC

** Advanced Gotcha: Witnessing

A (probably) surprising result

#+BEGIN_SRC typescript :tangle snippets/withoutWitness.ts
type Some<T> = { _tag: "Some"; value: T };
type None = { _tag: "None" };
type Maybe<T> = Some<T> | None;

type UnwrapMaybe<X extends Maybe<any>> = X extends Maybe<infer T> ? T : never;

type T01 = UnwrapMaybe<Some<string>>; // string
type T02 = UnwrapMaybe<None>; // unknown ??? ðŸ¤¨
type T03 = UnwrapMaybe<Maybe<string>>; // unknown ??? ðŸ¤¨

export { T01, T02, T03 };
#+END_SRC

- [[file:snippets/withoutWitness.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwgHgCoD4oF4oG8oD6wAhgOYBcUARPElQNxQBuxANgK4SWpQC+9AKFCQoAOTgA7aDnxEylKuKlU+g4dACyxEACMUGbLET7MAHzGSIgoeGgBVCQHcATsTBbdKABpQIAD2AICQATAGcoDz1kYgkQdEwcH39AkPDIlABLCQAzCGcoAwB+AqhKKSY863UCgAYARkMHFzd05FoUUOBnLNJ4xgB6fqhO7olSGxFUGoAmRqdXd20opQh0AaH2CQBrCThHCShCo6hAPg3ACl2J6CmAZjnmxc9kVpGevqhBqE2dvYOj4vOBAJ-GA4M5gHhanUADS1aYwm6qARAA][Playground]])

This is because the Type Matching (aka Type Destructuring) worked (otherwise we
would have got back ~never~) but the inference (keywordd ~infer~) failed because
there's no type witness in the type structure, meaning there's no place holding
the type information.

#+BEGIN_SRC typescript :tangle snippets/withWitness.ts
type Some<T> = { _tag: "Some"; value: T };
type None<T> = { _tag: "None"; _witness: T };

// NOTE: you can always populate this value with `undefined as T` placeholder
type Maybe<T> = Some<T> | None<T>;

type UnwrapMaybe<X extends Maybe<any>> = X extends Maybe<infer T> ? T : never;

type T01 = UnwrapMaybe<Some<string>>; // string
type T02 = UnwrapMaybe<None<string>>; // string
type T03 = UnwrapMaybe<Maybe<string>>; // string

const none = <T>(): None<T> => ({ _tag: "None", _witness: undefined as T });

const noneString = none<string>();

type T04 = UnwrapMaybe<typeof noneString>; // string

export { T01, T02, T03, T04 };
#+END_SRC

- [[file:snippets/withWitness.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAyg9gWwgHgCoD4oF4oG8oD6wAhgOYBcUARPElQNxQBuxANgK4SWpQC+9AKFCQoAOTgA7FBmx5CJCtXFSGhAO4BLYFIDOO7n0ECA9MbEB5VAFFKIOOygBjYhKhs1xEDqhg4YdqzEwNDAABYa3iwc0JphUAAG7BIAJhAAZhpSyW7eqPE+gY4QoXCsqQBOQuDQALKeAEbSmDi0TVAAPmKSTUbC0ACqEmrlxGB1II3IABpQEAAewSne45MuIOjNUDPzi8nLDSiZaRDlUDIA-GdQlFJMJ73VZwAMAIyyg8OjKyityDrA5UypA2jFMUH+gIkpCqIlQTwATO8hiMxgdkMoUBCgSCoGCsVCYdA4QBmJGfVETFDfP4A7HoUFmfHQgSOST-KASbqyNDoAAUAEpKBiedhMLz8EQyJQqBiqAAadRaXT6KBJVIZLI5K68flGVkSdmcqQwWlQ2RGzGm4ECh6wp4AFjJKOpfTgaQ53RNkOBDPBVoEAnmvnKwDkcJeCrh8MjT2JMcd-AEQA][Playground]])

** Exercises

#+BEGIN_SRC typescript :tangle snippets/inferName.ts
// eslint-disable-next-line
// @ts-nocheck

type GetName<X> = TODO;

type r01 = GetName<{ name: "Gabriele" }>;
type T01 = Expect<Equal<r01, "Gabriele">>;

type r02 = GetName<{ name: string; age: number }>;
type T02 = Expect<Equal<r02, string>>;

type r03 = GetName<{ age: number }>;
type T03 = Expect<Equal<r03, undefined>>;

type r04 = GetName<{
  name: { firstName: string; lastName: string };
  age: number;
}>;
type T04 = Expect<Equal<r04, { firstName: string; lastName: string }>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/inferName.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoAOLhEAOUwBbcAB4AGgD5QAXlAAVAPIARTQG5ufQaABOABgCMqkWMkzZAb1Dxp4AFygARMJwnY4PE9QAF9FAyMhdUtrAFEiQSZEWRiARwBXTGhZcwsAGi8fbD8A8E9FMMMBIXMAJmtRCVdHZ1cPSEQ-eABzPVBMLvdnNKlscBMQioiNMzq1OISk1Iys2vz2zq7ygx4q0zMAZnrbJqd+wfhh0fHQ8N2ow7n49kX0zOyD-LT4VHAAMwRwKgtpVjOYACxHRr2BzkUAtGQeJz-EztOyDdYIHqgaCYVGtUAY7ohAxws4eC4jMYGG47YxRCGPBbJV4rMxg-JI2AoqHojqY3o4vEIgl8omhCq0yI6TTWQgANypktA82esnUEBI4G+kFAHTS4GUanUt2MSze8nyAE1DbDQAAKNWKO0ASlUynVxEQWtQOvkoAA-KArB4aq7Pd6dY6XW6NBqvdrQJaA0HQCHbXDA3rwOnU6BfplIOBtsR+AwTIhQE4onlpjV8vd62z69LieQgA][Playground]])
- [[file:solutions/inferName.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBA4hwDkCGBbCAeAGgPigXikyggA9gIA7AEwGcoBvKC1CALigEsKAzCAJygIoAXygB+QVHYBXahG5cIVANwAoVaEhQ+ABgCM+WPGRp0jZmnYAiGEgBGfDhAA2EKyOxrN0ACr7DAKIkkADGwOgBAI7SSM7ounoANFA29o4ubtie6t7aOgBMhnCILGZMLOw0wI4UAObKUEi1bEzSKHb8Hl7gvgWBwRBhEdGx8QXJVTW1WWoaPXkAzEXGpYxNLRRtHQLC2bl+SwRBoeFRMXG6C8myVPKKVDM587oALMslpvSqUOWWDFAKPhVEwtSZcepQZxIYEVKBguoiNQ-dbsTbtfhqXbdLR+N5HAZDM6jV7JRiAmF-eEQqEU0HVcEebJzHEAeQAIizDBQIAA3DHM6DHQbhHzEMiUWhQarSCC4Ag+bGCkZxTDJACacu+UAAFOgfNhtQBKfC4UWkcjUOhECQGdj5Y3miV0PUG414U1ii2StXiKC2qD5LU-CTSiBBqQA2I0CCzUhgAD2fGA-z8SSgfnyyQOWZ0Lyz7M5wjUQA][Playground]])

#+BEGIN_SRC typescript :tangle snippets/and.ts
// eslint-disable-next-line
// @ts-nocheck

type AND<A, B> = TODO;

type r01 = AND<true, true>;
type T01 = Expect<Equal<r01, true>>;

type r02 = AND<false, false>;
type T02 = Expect<Equal<r02, false>>;

type r03 = AND<true, false>;
type T03 = Expect<Equal<r03, false>>;

type r04 = AND<false, true>;
type T04 = Expect<Equal<r04, false>>;

type TODO = never;
type Expect<T extends true> = T;
type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
    ? true
    : false;

export { T01, T02, T03, T04, TODO };
#+END_SRC

- [[file:snippets/and.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/PTAEFMGcBsEsDsAuBaAJrSBDARtcz5wAPFOQgKBFAAFFICB7AYwAtwmBrc8xATwAdwoAIIA5ACIAeYQBpQAIQB8oALygAKgHlxmgNzc+g0ACcADAEZVIiZMTGAruDl3Hi-YaHqLVgKJFBTIiSPgCO9pjQkmbmzg7gim4GAkJmAExWYlIAZhGQTqA50HmJHhqm6Wp+AUGh4ZFpcoXFiTzJJqYAzBk2LvlN8e5tXl2V-uw1YRFRnY258S2lZgAs3dlzsa6DRl4ro9XBk-WmS7NF8-qt29qaVoQAbuDGW0JV45LqECTg8KiQoL3KNTqZ6gWpTAAacgAmoDyKBQAAKd6KBEASlUyg+xEQ31+oHBoAA-KBLAAuUCpdHY3F-ZFojEaT44n5-KFEkmgcmpOHw9m9Hnw8n9C7EfgMYyIUAAbzKMTKqTkw0Vx0V11AAF99EA][Playground]])
- [[file:solutions/and.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/C4TwDgpgBAggcgEQDwwDRQEID4oF4oDaamAulBAB7AQB2AJgM6HABOArhOqx2QPxTdoALigAzAIYAbBhADcAKHmhIUFgAYAjHliIkgruwhYFy6ABVN2gKIVIAY2BIrARzZSk6jQY5Zji06pqAEza8MgS0pxiUjJ+ARYh+Db2ji5ukh7B6BGxfkrg0OoAzKG6+tGRcQVQFiVJthAOTq7uxdkxRnkB6gAspeEd3kYm1RZ99SnN6Zk97ZVdowDyCIvaNBAAbhAsIyrJjY5m5FS0jAKGOPhmu9Bp7gAa6ACal-JQUAAUSGZYHwCUeBwR0o1HoTHuUH4WhEQQBINOTG+vwBuCBx1BZyekKg0KgQTe72xggJ7xEOTkikoYAA9ixgFAAN41TToBKstRFdmzGrLVYAXwUQA][Playground]])

* Slide 1
This is an example of a slide

#+BEGIN_SRC typescript :tangle snippets/example.ts
export const z = "foo";
#+END_SRC

- [[file:snippets/example.ts][Snippet]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBAXjAvDARAMxCFBuAUEA][Playground]])
- [[file:solutions/example.ts][Solution]] ([[https://www.typescriptlang.org/play/?#code/MYewdgzgLgBAnjAvDARAMxCFBuAUEA][Playground]])

* Slide 2
Content

* Slide 3
Content
